一般来说，解决分布式事务就是协调事务和最终一致性方案。协调事务的方案有2PC、3PC、XA。最终一致性方案有本地消息表、TCC、Saga。但这里每一种方案都不是很完善，比如协调事务不管是 2PC 还是 3PC，都必须引入协调者，那协调者本身就要保证高可用性。如果是高可用的，那么他的一致性问题也需要考虑协调不一致的问题，比如一方提交或者回滚成功了，第二方提交或者回滚失败。2PC 和 3PC 都是降低这种情况发生的概率，不能完全避免。同时 2PC 和 3PC 都存在一定程度的阻塞，性能相对会差一点。而最终一致性方案最大的优点是无阻塞，能供提供良好的性能，比较适合高并发场景，但是它无法保证强一致性一致，比如本地消息表可能会存在写入失败的问题或者更新失败的问题。TCC 要先预留资源，还有涉及幂等的问题。所以分布式事务时绝对遵循CAP理论的。当分区条件满足时，一致性和可用性就无法同时满足。



怎么同时解决一致性和可用性的问题



## 分布式事务

定义：为了保证高可用，不同的微服务对应不同的数据库，在微服务架构下保证的这几个数据库的事务。



### CAP 定理

CAP 理论主要描述了在一个分布式系统中同时只能满足CP或者AP， 三个是无法同时满足的。

1. 一致性（C）：客户端发出去的请求能读取到最新的写入结果。
2. 可用性（A）：客户端发出的每个请求服务端必须给出回应。
3. 分区容错性（P）：分布式节点因网络原因彼此失联后，系统能够继续运行。

#### 一致性（C）和可用性（A）为什么不可能同时成立

因为可能通信失败（即出现分区容错）。

如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，可用性不成立。

如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。

综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。

只有在单点架构才能同时满足CA。



- 何时要满足CP？

  对一致性要求高的场景。例如我们的Zookeeper就是这样的，在服务节点间数据同步时，服务对外不可用。

- 何时满足AP？

  对可用性要求较高的场景。例如Eureka，必须保证注册中心随时可用，不然拉取不到服务就可能出问题。

分布式系统的初衷是提高系统整体的可用性，所以通常来说在CP和AP之间会选择AP。

### Base理论

- 基本可用（Basically Available）
- 软状态（Soft State）
- 最终一致性（Eventually Consistent）：系统可以允许一段时间的不一致，但是经过一段时间后，最终数据要恢复一致。



### 2PC（两阶段提交）

1. 准备阶段（投票阶段）：协调者询问所有事务参与者是否准备好提交。

   ![img](https://pic3.zhimg.com/v2-5b7799d96e341c181df46144e2325546_b.webp?consumer=ZHI_MENG)

2. 提交阶段

   1. 协调者若在上一步中收到所有事务参与者回复的 prepared 消息，则先将本地事务状态置为commit，然后向其他参与者发送commit指令，让他们立即执行提交操作。（所有参与者投赞成票）
   2. 协调者若没有收到全部的prepared消息，则将本地事务状态置为abort，然后向其他参与者发送abort指令。（有参与者投反对票）

缺点：
1. 单点故障问题：2PC非常依赖协调者，若协调者故障会影响所有的参与者。
2. 阻塞问题：在准备阶段、提交阶段，每个事物参与者都会锁定本地资源，并等待其它事务的执行结果，阻塞时间较长，资源锁定时间太久，每个事务参与者都要等最慢的那个参与者处理完，因此执行的效率就比较低，性能较差。
3. 一致性风险：如果只有一部分参与者收到commit请求，就会导致数据不一致。



### 3PC（三阶段提交）

1. 询问阶段：首先协调者开启事务事务，然后向所有参与者发送 CanCommit 指令询问参与者是否具备事务执行条件。

2. 准备阶段：协调者会所有参与者发送 PreCommit 指令。

   **这里与2PC不同的是，在进入准备阶段后，如果参与者迟迟没有收到协调者的消息（网络分区或协调者故障），那么此时参与者会有超时机制，当参与者超时之后会执行统一默认策略进行事务commit。**

3. 提交阶段



### 3PC与2PC对比

1. 性能问题（相比2PC性能更差）

   2PC需要锁定资源，并且时间取决于最慢的一个参与者，在3PC里这样的情况并未发生任何变化，3PC也还是需要锁定资源，同样也是必须要等待所有参与者响应才能进行下一步流程，反而3PC增加了一个阶段的协商通讯，这就使得3PC通信成本更高，性能反而会更差。

2. 协调者故障导致的事务阻塞问题（解决）

   因为3PC增加了询问阶段，然后在准备阶段增加了参与者超时机制，所以协调者故障并不会一直阻塞着事务进行，参与者超时之后会进行事务commit。

3. 数据不一致的风险（还是存在）

   如果协调者第二阶段的决策是abort，此时协调者把abort指令发送给了部分参与者之后挂掉了，那么收到了abort指令的参与者进行了数据回滚，但是没有收到abort指令的参与者会根据超时机制进行事务commit，最终就会有部分参与者rollback了，部分参与者进行了commit，最后数据不一致。



### TCC

https://www.cnblogs.com/jajian/p/10014145.html

TCC模式可以解决2PC中的资源锁定和阻塞问题，减少资源锁定时间。

#### 基本原理

它本质是一种补偿的思路。事务运行过程包括三个方法：

- Try：该阶段主要做业务可行性检查并预留事务所需要的资源，保证预留出来的资源与其它的事务隔离开来。一般都是锁定某个资源，设置一个预备类的状态，冻结部分数据。
- Confirm：当所有事务参与者在Try阶段都执行成功后，进入Confirm阶段。此阶段将直接使用Try阶段预留资源进行业务操作。
- Cancel：任意一个参与者在当Try阶段执行失败，则整体进入Cancel阶段，此阶段将释放Try阶段预留的资源。

#### 和2PC的区别

- try、confirm、cancel都是独立的事务，不受其它参与者的影响，不会阻塞等待他人
- try、confirm、cancel由程序员在业务层编写，锁粒度有代码控制

#### 优缺点

- 优势

  TCC执行的每一个阶段都会提交本地事务并释放锁，并不需要等待其它事务的执行结果。而如果其它事务执行失败，最后不是回滚，而是执行补偿操作。这样就避免了资源的长期锁定和阻塞等待，执行效率比较高，属于性能比较好的分布式事务方式。

- 缺点

  - 代码侵入：需要人为编写代码实现try、confirm、cancel，代码侵入较多
  - 开发成本高：一个业务需要拆分成3个步骤，分别编写业务实现，业务编写比较复杂
  - 安全性考虑：cancel动作如果执行失败，资源就无法释放，需要引入重试机制，而重试可能导致重复执行，还要考虑重试时的幂等问题