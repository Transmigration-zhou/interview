[toc]

## 1.面向对象及特性

面向对象是一种思想，可以将复杂问题简单化，让我们从执行者变成指挥者面向对象的三大特性：==封装/继承/多态==

- 封装：将事物封装为一个类，减少耦合，隐藏细节。保留特定的接口与外界联系，当接口内部发生变化时，不影响外部的调用方法
  - JavaBean的封装  属性一般使用private修饰，为属性提供public修饰的set/get方法

- 继承：从一个已知的类中派生出一个新的类，新类可以拥有已知类的行为和属性，并且可以通过覆盖或重写来增强已知类的能力
- 多态：多态的本质就是一个程序中存在多个同名的不同方法，主要通过 子类对父类的覆盖、类里对方法的重载、将子类作为父类对象来使用、实现接口等方法实现的

### 1.1 面向对象和面向过程的区别

**面向过程**：**面向过程性能比面向对象高**。因为类的调用需要实例化，开销较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux等时都采用面向过程开发。

**面向对象**：**面向对象易维护，易复用、易拓展**。因为面向对象有封装、继承、多态等特性，所以可以设计出低耦合的系统，可以使系统更加灵活，也更加易于维护

### 1.2 多态

https://blog.csdn.net/SIayer/article/details/104686885

**多态分两种:**

(1) 编译时多态(设计时多态):方法重载

 (2) 运行时多态:JAVA运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态 (我们平时说得多的事运行时多态,所以多态主要也是指运行时多态)

**多态要点:**

1. 多态是方法的多态，不是属性的多态(多态与属性无关)。
2. 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。
3. ==父类引用指向子类对象后，用该父类引用调用子类重写的方法==，此时多态就出现了。



**分析**

```java
class A {
    public String show(D obj) {
        return ("A and D");
    }

    public String show(A obj) {
        return ("A and A");
    }
}

class B extends A {
    public String show(B obj) {
        return ("B and B");
    }

    public String show(A obj) {
        return ("B and A");
    }
}

class C extends B {
}

class D extends B {
}

class E {
    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new B();
        B b = new B();
        C c = new C();
        D d = new D();
        System.out.println(a1.show(b));   //A and A
        System.out.println(a1.show(c));   //A and A
        System.out.println(a1.show(d));   //A and D
        System.out.println(a2.show(b));   //B and A
        System.out.println(a2.show(c));   //B and A
        System.out.println(a2.show(d));   //A and D
        System.out.println(b.show(b));    //B and B
        System.out.println(b.show(c));    //B and B
        System.out.println(b.show(d));    //A and D
    }
}
```

- 成员变量：编译看左，运行看左（因为无法重写）；
- 成员方法：编译看左，运行看右（因为普通成员方法可以重写，变量不可以）；
- 静态方法：编译看左，运行看左（因为属于类）；

解析：https://blog.csdn.net/clqyhy/article/details/78978785



## 2.java属于编译型还是解释型语言

java的执行经历了编译和解释的过程，是一种先编译后解释的语言，不可以单纯归到编译型或解释型语言



## 3.八大基本数据类型

| **数据类型** | **封装类型** | **占用字节** | **默认数值** | **取值范围**                                                 |
| ------------ | ------------ | ------------ | ------------ | ------------------------------------------------------------ |
| boolean      | Boolean      | 1（8位）     | false        | true,false                                                   |
| byte         | Byte         | 1（8位）     | 0            | -128 ~ 127（$-2^{7}$ ~ $2^{7}-1$）                           |
| short        | Short        | 2（16位）    | 0            | -32768 ~ 32767（$-2^{15}$ ~ $2^{15}-1$）                     |
| int          | Integer      | 4（32位）    | 0            | -2147483648~2147483647（$-2^{31}$ ~ $2^{31}-1$）             |
| long         | Long         | 8（64位）    | 0.0l         | -9223372036854775808~9223372036854775807（$-2^{63}$ ~ $2^{63}-1$） |
| float        | Float        | 4（32位）    | 0.0f         | 1.4E-45~3.4028235E38                                         |
| double       | Double       | 8（64位）    | 0            | 4.9E-324~1.7976931348623157E308                              |
| char         | Character    | 2（16位）    | '\u0000'     | '\u0000' ~ '\uffff'                                          |



## 4.抽象类和接口

### 抽象类：

- 一个类中有抽象方法，这个类就变成了抽象类。
- 抽象类中class的前面必须有abstract修饰符。
- 抽象类中可以有普通方法，也可以有抽象方法，而抽象方法的个数可以是==0个==，也可以是多个。
- 子类继承父类，必须重写全部的抽象方法，除非这个类也变成了抽象类。

### 接口：

- 表面上看，接口是一种特殊的抽象类，但是类是类，接口是接口，是并列的关系。
- 接口中所有方法都必须是抽象的。（**1.8之后允许接口定义非抽象方法。**1.8新增了静态方法和默认方法，静态方法是不能被重写的，默认方法是可以被重写也可以不重写的）
- 接口中方法定义默认为public abstract类型，成员变量默认为public static final 类型。（如果省略，系统会默认补全）。

### 抽象类和接口区别：

- 抽象类中可以没有抽象方法，也可以抽象方法和非抽象方法并存；接口中的方法在JDK8以前只能是抽象的，JDK8版本开始提供了接口中方法的default实现
- 抽象类和类一样都是==单继承==的；接口可以==实现多个父接口==
- 抽象类中可以存在普通的成员变量；接口中的变量必须是static final类型的，必须被初始化，接口中==只有常量，没有变量==。

- 当我们仅需要定义一些抽象方法而==不需要额外的具体方法或变量==时，我们可以使用接口，反之使用抽象类，因为抽象类里可以有非抽象方法和变量
- 从设计层面讲，抽象类是对类的抽象，是一种模板设计，而接口是对行为的抽象，是对行为的规范



抽象类继承，如果子类也是一个抽象类，并不要求一定重写父类方法。如果子类不是抽象类，则要求子类一定要实现父类中的抽象方法。

接口类继承，如果是一个子接口，可以扩展父接口的方法；如果是一个子抽象类，可以部分或全部实现父接口的方法；如果子类不是抽象类，则要求子类一定要实现父接口中定义的所有方法。



## 5.重载和重写

重载（Overload）：同一个类里，方法名相同，参数类型不同、个数不同、顺序不同的方法。即重载就是同一个类里多个同名方法根据不同的传参执行不同的逻辑处理。

重写（Override）：子类对父类方法的重写改造，外部样子不变，内部逻辑可言变。



## 6.equals和==

对于 == 这个关系运算符来说，它有两种使用场景：

- 作用于基本数据类型： 比较的是值

- 作用于对象：比较的是内存地址

不过有一个特殊情况，那就是 Integer，我们会发现，有时候比较的两个 Integer 对象具有相同的值时候，使用 == 的结果是 true ，但实际上，== 比较的是对象的引用，应该返回 false 才对

这是因为 Integer 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 == 比较也能能到正确的结果，但是不推荐用关系运算符比较



而 equals 呢，适用于==对象==之间的比较，而且比较的也是==内存地址==（Object 类默认的 equals() 的行为是比较对象的引用而非具体内容）。但是，==大部分类都会重写 equals 方法==，使其变成基于值的比较，比如 Integer、String 等等。



## 7.equals和hashCode

https://blog.csdn.net/u011583316/article/details/107129546

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220217161913)

在HashMap中的比较key是这样的，先求出key的hashCode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的。若equals()不相等则认为他们不相等。

- 如果只重写hashCode()不重写equals()方法，当比较equals()时，其实调用的是Object中的方法，只是看他们是否为同一对象（即进行内存地址的比较）。
- 如果只重写equals()不重写hashCode()方法，在一个判断的时候就会被拦下HashMap认为是不同的Key。



## 8.StringBuffer和StringBuilder的区别、String不可变

**可变性**

String类里是使用final关键字来修士字符数组保存字符串的`private final char value[]`,所以String对象不可变。（在java 9中，String类使用byte数组存储字符串）

StringBuiler和StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder里也是使用`char[] value`来保存字符串的，但没有使用final关键字修饰，使用这两种对象都是可变的

**线程安全性**

String中的对象是不可变的，可以理解为常量，线程安全。

StringBuffer对方法加了同步锁所以是线程安全的

StringBuilder没有对方法加同步锁，所以是非线程安全的。

**性能**

每次对String类型进行改变时，都会产生新的String对象，然后指针指向新的String对象

StringBuffer和StringBuilder每次都会对对象本身进行操作，不会改变对象引用



## 9.编译时异常与运行时异常

编译时异常：编译过程中出错，不解决无法运行。

运行时异常：RuntimeException类及其子类在编译过程中不会报错，运行时会报错。这些异常一般是==由程序逻辑错误引起==的。




## 10.Java 中的几个 IO 流

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220221015314.jpg)



## 11.a+=b和a=a+b有什么区别

在两个变量的数据类型一样时，a+=b 和a=a+b 是没有区别的。

a+=b会自动转型，a=a+b不会自动转型，会抛出编译错误。

a+=b --> a=(a.Type)a+b;//返回的是a类型
a=a+b --> a=a+b;//返回类型是a类型与b类型中的最高类型



## 12.深拷贝和浅拷贝的区别

指针浅拷贝后会有两个指针指向同一块内存空间，一个指针析构后另一个指针再析构就会报错

深拷贝是开辟了一块新的内存空间来存放指针所指向的数据，两块内存空间独立,即使析构了一个指针也不会影响另一个指针。



# 泛型

## 1.什么是泛型

泛型是一种参数化类型，即把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。

泛型是JDK5提供的一个新特性。它主要提供的是编译时期类型的安全检测机制。这个机制允许程序在编译时检测到非法的类型，从而进行错误提示。

## 2.什么是泛型的类型擦除

https://www.nowcoder.com/discuss/789388?type=all&order=recall&pos=&page=0&ncTraceId=&channel=-1&source_id=search_all_nctrack

因为泛型其实只是在编译器中实现的而虚拟机并不认识泛型类项，所以要在虚拟机中将泛型类型进行擦除。也就是说，「在编译阶段使用泛型，运行阶段取消泛型，即擦除」。擦除是将泛型类型以其父类代替，如String 变成了Object等。其实在使用的时候还是进行带强制类型的转化，只不过这是比较安全的转换，因为在编译阶段已经确保了数据的一致性。

# 注解

## 1.java中的元注解

java中有四个元注解，负责注解其他的注解

- @Target ：说明注解所修饰的范围
- @Retention：保留策略，定义了注解保留时间的长短

- @Documented：标记注解，标注生成javadoc的时候是否被记录
- @Inherited：标记注解，子类会继承父类中使用的被@Inherited修饰的注解



## 2.如何定义注解

使用@interface

```java
public @interface MyAnn{}
```

定义带属性的注解

```java
public @interface MyAnn{
    String value();
    int value1();
}
@MyAnn(value1=100,value="hello")
public class Myclass{
}
```



# 反射

https://flying-veal.notion.site/13893931261e4dcfa620988756a43803

## 1.反射机制

反射机制：能动态获取信息和动态调用对象方法的功能。对于任意一个类，都能知道这个类的所有属性和方法。对于任意一个对象，都能调用它任意一个方法和属性

优势：运行期类型的判断，动态类加载：提高代码灵活度

劣势：性能瓶颈，反射相当于一系列解释操作，通知JVM要做的事情，比单纯的java代码慢



## 2.反射机制的作用（功能）

- 在运行时判断任意一个对象所属的类
- 在运行时构造一个类的对象

- 在运行时判断任意一个类所具有的成员变量和方法
- 在运行时调用任何一个对象的方法，生成动态代理



## 3.与反射相关的类

- Class：表示类，用于获取类的相关信息
- Field：表示成员变量，用于获取实例变量和静态变量

- Method：表示方法，用于获取类中的方法参数和方法类型
- Constructor：表示构造器，用于获取构造器相关参数和类型



## 4.获取Class类的三种基础方式

1.通过类名称.class来获取Class类对象

2.通过对象.getClass()方法来获取Class类对象

2.通过类名称加载类Class.forName()类获得Class



## 5.反射的具体原理

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220218055433.png)

