[toc]



## 1.进程、线程、协程

[从 linux内核来看进程与线程的异同](https://blog.csdn.net/smilejiasmile/article/details/109389607)

### 进程与线程的区别

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
2. 进程是资源分配的基本单位，线程是独立调度的基本单位。
3. 进程间**不共用**变量与资源；线程间**共用**变量与资源。
4. 线程的划分尺度小于进程，使得多线程程序的并发性高。
5. 线程不能够独立执行， 必须依存在进程中。
6. 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一进程下的所有线程共享该进程的内存空间，即共享堆、全局变量、静态变量、指针、引用、打开的文件等，而独自占有栈空间，线程之间切换的开销小。
7. 进程间通信（IPC）需要借助操作系统，比较麻烦；线程间可以直接读写进程数据段来进行通信，但需要处理线程同步问题。
8. 线程存在于进程中，因此一个进程的全局变量由所有的线程共享。由于线程共享同样的系统区域，操作系统分配给一个进程的资源对该进程的所有线程都是可用的，正如全局数据可供所有线程使用一样。

### 为什么要引入线程？

线程可以看作是轻量级的进程，但是它比进程更容易创建，也更容易撤销。（即线程成为独立调度的基本单位）



### 协程

- 协程是一种比线程更加轻量级的存在。

- 一个线程也可以拥有多个协程。

- 协程的调度完全==由用户控制==。

- **协程间切换只需保存任务的上下文，没有内核的消耗。**协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

  ![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220328103921)



## 2.进程状态

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220321105451.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto)

- 就绪态（ready）：等待被调度
- 运行态（running）
- 阻塞态（waiting 等待态）：等待资源

### 引起进程状态转换的具体原因

运行态→阻塞态：等待使用资源；如等待外设传输；等待人工干预。

阻塞态→就绪态：资源得到满足；如外设传输结束；人工干预完成。

运行态→就绪态：运行时间片到；出现有更高优先权进程。

就绪态→运行态：CPU 空闲时选择一个就绪进程。



## 3.进程调度算法

- **先来先服务（FCFS）**

  非抢占式的调度算法，按照请求的顺序进行调度。

  有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

- **短作业优先（SJF）**

  非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

  长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

- **最短剩余时间优先（SRTN）**

  最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。

  如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

- **高相应比优先（HRRN）**

  响应比 =（等待时间+要求服务时间）/要求服务时间

- **时间片轮转（RR）**

  公平地、轮流地为各个进程服务，让每个进程在一定时间隔内都可以得到响应

  按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。

- **优先级调度**

  按照优先级高低进行调度，有抢占式和非抢占式。

  系统进程优先级 **高于** 用户进程
  前台进程优先级 **高于** 后台进程

  操作系统更**偏好 I/O型进程**

- **多级反馈队列**

  设置多级就绪队列，各级队列==优先级从高到低==，==时间片从小到大==。

  新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾。

  可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。



## 4.进程间通信方式（IPC）

1. 管道

   通过**内核缓冲区**（可以看做一个循环队列）实现数据传输，进程以**先进先出**的方式从缓冲区存取数据。

   ![Pipe with one](https://gitee.com/Transmigration_zhou/pic/raw/master/pipe_with_one.jpg)

   1. 无名管道

      管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。在 shell 中，我们经常使用 | 将两个命令连接起来，它的作用是把前一个命令的输出作为输入后一个命令的输入。

   2. 有名管道

      有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用。

2. 消息队列

   ![image-20220909161409746](https://gitee.com/Transmigration_zhou/pic/raw/master/image-20220909161409746.png)

   消息队列存放在内核中，可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

3. 共享内存

   ![Shared Memory](https://www.tutorialspoint.com/inter_process_communication/images/shared_memory.jpg)

   系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。

   使⽤共享内存的话，需要对共享的进程对共享内存的访问进⾏同步，防⽌访问对于共享数据的破坏，例如通过互斥锁或者信号量进行同步。

   共享内存的实现步骤：

   1. 创建共享内存区，通过shmget实现。在物理内存中开辟一块共享内存区。
   2. 把这块共享内存区挂接映射到两个进程的地址空间上，通过shmat实现。
   3. 完成通信之后，撤销内存映射关系，通过shmdt进行脱离。
   4. 删除共享内存区，通过shmctl实现。

   ==共享内存是最快的一种IPC方式。==因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要进行四次的数据拷贝（1. 用户空间到内核；2. 内核到内存；3. 内存到内核；4. 内核到用户空间），而共享内存则只拷贝两次数据（1. 用户空间到内存；2. 内存到用户空间）。

4. 套接字socket

   主要用于在客户端和服务器之间通过网络进行通信。

5. 信号

   用于通知接收进程某个事件已经发生，比如按下`ctrl + C`就是信号。

6. 信号量

   类似于计数器，控制多个进程多共享资源的访问。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。



## 5.死锁

### 什么是死锁?

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。

引起死锁的原因主要有两个，一是与资源的分配策略有关，二是与并发进程的执行速度有关。	

### 死锁的条件

- 互斥条件：一段时间内某资源仅为一进程所占用。
- 请求和保持条件：已经得到了某个资源的进程可以再请求新的资源。
- 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
- 循环等待条件：死锁发生时，系统中一定有两个或以上的进程组成的一条环路，该环路中每个进程都在等待着下一个进程所占有的资源。

死锁发生时，以上四个条件一定是同时满足的，如果其中任何一个条件不成立，死锁就不会发生。

### 处理方式

#### 鸵鸟策略

忽视这个问题，认为死锁不可能在系统内发生。

因为解决死锁问题的代价很高，这样做可以获得更高的性能。

大多数操作系统，处理死锁问题的办法仅仅是忽略它。

#### 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复

#### 死锁预防

在程序运行之前预防发生死锁。

- **破坏互斥条件**：把独占型资源改造成共享性资源，使资源可同时访问而不是互斥使用。
- **破坏请求和保持条件**：规定所有进程在开始执行前请求所需要的全部资源。
- **破坏不剥夺条件**：当某进程获得了部分资源但得不到其他资源，则释放已占有的资源。
- **破坏循环等待条件**：给资源统一编号，进程只能按编号顺序来请求资源。

#### 死锁避免

在程序运行时避免发生死锁。

银行家算法



## 6.一个程序从开始运行到结束的完整过程

程序要运行起来，必须经过四个步骤：预处理、编译、汇编和链接。

- 预处理：主要处理源代码文件中的以“#”开头的预编译指令，生成.i文件

  - 展开#define宏定义
  - 处理所有的条件编译指令#if
  - 插入包含的头文件\#include
  - 删除所有注释
  - 添加行号以便编译错误时能够显式行号
  - 保留#pragma编译器指令

- 编译：把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件，生成相应的.s文件（汇编文件）

  - 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。
  - 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。
  - 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义。
    - 静态语义：在==编译期==就可以确定的语义。如声明与类型的匹配、类型的转换。
    - 动态语义：在==运行期==才能确定的语义。如两个整数做除法，除数为0。

  - 优化：源代码级别的一个优化过程。
  - 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言
    表示。
  - 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。

  ![img](https://pic4.zhimg.com/v2-4dd909bc437680a2dad7064c4bb5e0e3_b.jpg)

- 汇编：将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应着一条机器指令最后生成一个.o文件（目标文件、二进制文件）

- 链接：将有关的目标文件彼此相连接，生成可执行程序

  - **1、静态链接：** 编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。

    运行速度快：在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

  - **2、动态链接：** 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

    共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；

    更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

    性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。


### 为何要链接？汇编器为何不直接输出可执行文件而是输出一个目标文件？

程序由多个模块组成，模块之间需要交互组合形成程序，模块间最常见的通信方式有模块间**函数调用和变量访问**，这需要知道目标函数和目标变量的**地址**。如果目标代码中有变量定义在其他模块或调用其他模块的函数，但每个模块都是**单独编译**，因此编译器会把这些地址搁置，链接时等链接器确定这些地址。因此编译器将源代码编译成未链接的目标文件，由链接器将目标文件链接形成可执行文件。



## 7.虚拟地址

### 虚拟地址和物理地址的关系：

虚拟内存和物理内存之间通过**页表**来**映射**

虚拟地址分为：页号和页内偏移

<img src="https://picx.zhimg.com/v2-2aa112cea1796651a4f60902bdf2f702_720w.jpg?source=172ae18b" alt="内存管理(三)——内存分页" style="zoom: 67%;" />

### 使用虚拟地址空间的**好处**：

1. 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。

   子进程执行到改变val的代码时，子进程就会发生写时拷贝。写时拷贝：顾名思义就是当代码执行到修改值的位置，子进程会拷贝一份当前相关代码通过页表映射到新的物理地址就区别于父进程中被修改变量的地址。

2. 可以缓解物理内存不足的压力，提高内存使用效率。

   当我们使用new malloc申请空间时实在虚拟内存上申请的，当你不需要使用这部分空间时，是不会给你分配物理空间的，只有当你第一次使用了这些地址才会通过内存管理算法给你开辟内存，构建页表映射关系，你才可以访问到。（延迟分配策略）



## 8.分页、分段、快表(TLB)

分页：页表记录块号。页的大小固定，系统自动生成页号，一维（只需一个符号表示地址）。

分段：段表记录段长和基址。段的大小由用户定，相当于是y=ax+b，先找到ax然后+b，二维（程序员需要段名和段内偏移）。

页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。

段页：把主存先分成若干段，每个段又分成若干页



为了解决虚拟地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。

快表命中，只需一次访存 快表未命中，需要两次访存。

快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像



## 9.页面置换算法（缺页中断算法）

- **最佳置换算法(OPT)**

  优先淘汰最长时间内不会被访问的页面。

  缺页率最小，性能最好；但无法实现

- **先进先出置换算法(FIFO)**

  优先淘汰最先进入内存的页面。

  实现简单；但性能很差，可能出现Belady异常

- **最近最久未使用置换算法(LRU)**

  优先淘汰最近最久没访问的页面

   性能很好；但需要硬件支持，算法开销大

- **时钟置换算法(CLOCK)**

  循环扫描各页面 第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第一轮没选中，则进行第二轮扫描。

  实现简单，算法开销小；但未考虑页面是否被修改过。

- **改进型的时钟置换算法**

  **(访问位，修改位)**的形式表示各页面状态

  第一轮:从当前位置开始扫描到第一个(0, 0)的帧用于替换。本轮扫描不修改任何标识位。表示该页面最近既未被访问，又未被修改，是最佳淘汰页。

  第二轮:若第一轮扫描失败，则重新扫描，查找第一个(1, 0)的帧用于替换。本轮将所有扫描过的帧访问位设为0。表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。 

  第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。本轮扫描不修改任何标识位。表示该页面最近已被访问，但未被修改，该页有可能再被访问。 

  第四轮:若第三轮扫描失败，则重新扫描，查找第一个(1, 1)的帧用于替换。表示该页最近已被访问且被修改，该页可能再被访问。

  算法开销较小，性能也不错



## 10.kill -9发生了什么？

`kill -9 pid`是向进程号为`pid`的进程发送`SIGKILL`信号，`SIGKILL`既不能被应用程序捕获，也不能被阻塞或忽略，其动作是立即结束指定进程。



## 11.硬链接和软链接的区别？

硬链接是指针，所有硬链接都指向同一个磁盘块，删除一个指针并不会真正删除文件，只有把指向该文件的所有指针全部删除，才会真的删除该文件；
软链接是另外一种类型的文件，保存的是它指向文件的全路径，访问时会替换成绝对路径，软链接可以理解为Windows上的快捷方式。



## 12.守护进程、孤儿进程与僵尸进程

- 守护进程是指==在后台运行，独立于控制终端，周期性地执行某种任务的进程==。Linux中大多数服务器就是用守护进程的方式实现的，如http进程等；

- 孤儿进程是指==父进程先退出，子进程还没有退出，此时子进程就是孤儿进程==，孤儿进程会被**init进程（进程号为1）**收养，当孤儿进程退出时，init进程会自动回收它们的状态；**孤儿进程不会有什么危害**

- 僵尸进程是指==子进程退出了，父进程没有退出且没有回收子进程的状态，此时子进程变为僵尸进程==，设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时间获取。僵尸进程会一只占用进程号，因为系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因没有可用的进程号而导致系统无法产生新的进程。

  如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。

### 如何避免僵尸进程？

- 父进程调用wait/waitpid等待子进程结束;
- 通过两次调用fork，父进程首先调用一个fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出，孙进程会变成孤儿进程由init进程领养。



## 13.用户态与内核态

- 用户态：用户态运行的进程可以直接读取用户程序的数据。

- 内核态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。

内核态和用户态之间的转换方式主要包括：==系统调用，异常和中断==。

（1）系统调用：用户进程通过系统调用申请使用操作系统提供的服务程序来完成工作，比如read()、fork()等。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现的，例如Linux的int 80h中断。

（2）异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

（3）中断：当外围设备完成用户请求的操作后，会向CPU发送中断信号。这时CPU会暂停执行下一条指令（用户态）转而执行与该中断信号对应的中断处理程序（内核态）



## 14.异常和中断的区别

中断

![image-20221025171432519](https://gitee.com/Transmigration_zhou/pic/raw/master/image-20221025171432519.png)

异常

![image-20221025171506318](https://gitee.com/Transmigration_zhou/pic/raw/master/image-20221025171506318.png)

相同点

- 最后都是由CPU发送给内核，由内核去处理
- 处理程序的流程设计上是相似的

不同点

- 产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的
- 内核需要根据是异常还是中断调用不同的处理程序
- 中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的
- 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中



## 15.线程同步和异步

线程同步指的是线程之间“协同”，即线程之间按照规定的先后次序运行。多个线程同时访问同一资源。

线程异步后一个任务不等待前一个任务结束就可以执行，不会阻塞代码的执行。异步通过callback形式调用。多线程只是异步编程的一种实现形式。

#### 线程同步有哪些方式？

- 互斥量（互斥锁）

  只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。

- 信号量

  它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。

  信号量允许多个线程同时进入临界区，而互斥量只允许一个线程进入临界区。

- 事件

  通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。
  
- 读写锁（共享-独占锁）

  对某些资源的访问会出现两种情况，一种是访问的排他性，需要独占，称之为写操作；还有就是访问可以共享，称之为读操作。

- 条件变量

  条件变量用来协调想要访问共享资源的那些线程，当共享资源的状态发生变化的时候，它可以用来通知被互斥锁阻塞的线程。



## 16.并发和并行

并发（Parallel）是指宏观上在一段时间内能同时运行多个程序

并行（Concurrent）则指同一时刻能运行多个指令

并发和并行都可以是很多个线程，就看这些线程能不能同时被多个cpu执行，如果可以就说明是并行，而并发是多个线程被一个cpu轮流切换着执行



## 17.操作系统中堆和栈的区别

堆与栈表示两种内存管理方式

1. 管理方式不同。

   堆的内存分配取决于程序员，C/C++可以手动释放该片内存。（malloc()/free()或new/delete）

   栈的内存分配取决于编译器，用户栈在程序运行期间可以动态的扩展和收缩。

2. 空间大小不同。

   每个进程拥有的栈大小要远远小于堆大小。

   栈内存是连续的空间，堆内存一般情况不是连续的，频繁地开辟空间，释放空间容易产生内存碎片（外碎片）。

3. 分配方式不同。

   堆都是程序中由malloc()函数动态申请分配并由free()函数释放的。

   栈的分配和释放是由编译器完成的，栈的动态分配由alloca()函数完成，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行申请和释放的，无需手工实现。

4. 增长方向不同。

   堆的增长方向向上，内存地址由低到高。

   栈的增长方向向下，内存地址由高到低。

5. 存放效率不同。

   栈内存的访问直接从地址读取数据到寄存器，然后放到目标地址。

   堆内存的访问更麻烦，先将分配的地址放到寄存器，在读取地址的值，最后再放到目标文件中，开销更大。



## 18.虚拟技术

虚拟技术指把一个物理实体转换为多个逻辑实体，主要有两种：时分复用技术和空分复用技术。

### 时分复用技术

多进程/多线程采用了时分复用技术，多个进程能在同一处理器上并发执行，让每个进程轮流占用处理器，每次只执行一小个时间片。

例子：既然一个程序需要被分配 CPU 才能正常执行，那为什么单核 CPU 的电脑中也能同时运行这么多个程序呢？

### 空分复用技术

虚拟内存使用了空分复用技术，将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，这些页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页从磁盘置换到内存中。空分复用技术的原理就是==把内存作为高速缓存来使用，只用来保存最频繁使用的部分程序，而把程序的大部分放在磁盘上==。

例子：这些程序同时运行需要的内存远大于 4 GB，那么为什么它们还可以在我的电脑上同时运行呢？



## 19.I/O多路复用

>  同步/异步概念描述的是用户线程与内核的交互方式。
>
> 阻塞/非阻塞描述的是用户线程调用内核操作的方式。
>
> 拿人烧水举例来说，(人的行为好比用户程序，烧水好比内核提供的系统调用)，这两组概念翻译成大白话可以这么理解：
>
> - 同步/异步关注的是水烧开之后需不需要我来处理。
> - 阻塞/非阻塞关注的是在水烧开的这段时间是不是干了其他事。
>
> https://www.cnblogs.com/linkenpark/p/12376343.html

多路复用指的是多个 socket 复用同一个线程。

Select、Poll、Epoll 三种多路复用的网络 I/O 模型。

select函数仅仅知道有几个I/O事件发生了，但并不知道具体是哪几个socket连接有I/O事件，还需要轮询去查找，时间复杂度为O(n)，处理的请求数越多，所消耗的时间越长。

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， **但是它没有最大连接数的限制**，原因是它是基于链表来存储的。

epoll可以理解为event pool，不同与select、poll的轮询机制，epoll采用的是事件驱动机制，每个fd上有注册有回调函数，当网卡接收到数据时会回调该函数，同时将该fd的引用放入rdlist就绪列表中。

当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。

epoll两种触发模式：

1. level 模式：该模式就是只要还有没有处理的事件就会一直通知
2. edge 模式：该模式是当状态发生变化时才会通知



## 20.linux命令

查看端口占用：使用命令「lsof -i :端口号」来查看某个特定的端口是否被占用。

查看CPU负载：使用命令「top」来查看系统的CPU负载。

查看内存占用：使用命令「free」来查看系统的内存占用情况。

发送信号给进程：使用命令「kill」来发送信号给进程，其中参数「-SIG」表示发送的信号，「pid」表示进程的ID。例如「kill -SIGTERM pid」表示发送终止信号给进程。

「netstat」通常用来查询系统的网络套接字连接情况

`netstat -a`：列出所有端口
`netstat -p`：显示正在使用socket的程序PID和名称
`netstat -s`：打印统计数据
`netstat -n`：显示IP地址，而不显示域名
`netstat -c`：持续输出
`netstat -l`：只显示监听端口
`netstat -at`：列出所有tcp端口
`netstat -atp` : 列出所有tcp连接端口及其应用程序
`netstat -lt`：只显示监听的tcp端口
`netstat -ltp`：只显示监听的tcp端口及其应用程序
`netstat -catp`：持续输出所有tcp连接端口及其应用程序

