[toc]



## 1.进程、线程、协程的区别

https://flying-veal.notion.site/a4ca2ea1cfda477f9063c86c00daab3a

[从 linux内核来看进程与线程的异同](https://blog.csdn.net/smilejiasmile/article/details/109389607)

### 进程与线程的区别

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
2. 进程是资源分配的基本单位，线程是独立调度的基本单位。
3. 进程间**不共用**变量与资源；线程间**共用**变量与资源。
4. 线程的划分尺度小于进程，使得多线程程序的并发性高。
5. 线程不能够独立执行， 必须依存在进程中。
6. 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一进程下的所有线程共享该进程的内存空间，即共享堆、全局变量、静态变量、指针、引用、打开的文件等，而独自占有栈空间，线程之间切换的开销小；
7. 进程间通信（IPC）需要借助操作系统，比较麻烦；线程间可以直接读写进程数据段来进行通信，但需要处理线程同步问题；

### 为什么要引入线程？

线程可以看作是轻量级的进程，但是它比进程更容易创建，也更容易撤销。（即线程成为独立调度的基本单位）



### 协程

- 协程是一种比线程更加轻量级的存在。

- 一个线程也可以拥有多个协程。

- 协程的调度完全==由用户控制==。

- **协程间切换只需保存任务的上下文，没有内核的消耗。**协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

  ![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220328103921)



## 2.进程状态

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220321105451.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto)

- 就绪态（ready）：等待被调度
- 运行态（running）
- 阻塞态（waiting 等待态）：等待资源

### 引起进程状态转换的具体原因如下：

运行态→阻塞态：等待使用资源；如等待外设传输；等待人工干预。

阻塞态→就绪态：资源得到满足；如外设传输结束；人工干预完成。

运行态→就绪态：运行时间片到；出现有更高优先权进程。

就绪态→运行态：CPU 空闲时选择一个就绪进程。



## 3.进程调度算法

- **先来先服务（FCFS）**

  非抢占式的调度算法，按照请求的顺序进行调度。

  有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

- **短作业优先（SJF）**

  非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

  长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

- **最短剩余时间优先（SRTN）**

  最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。

  如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

- **高相应比优先（HRRN）**

  响应比 =（等待时间+要求服务时间）/要求服务时间

- **时间片轮转（RR）**

  公平地、轮流地为各个进程服务，让每个进程在一定时间隔内都可以得到响应

  按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。

- **优先级调度**

  按照优先级高低进行调度，有抢占式和非抢占式。

  系统进程优先级 **高于** 用户进程
  前台进程优先级 **高于** 后台进程

  操作系统更**偏好 I/O型进程**

- **多级反馈队列**

  设置多级就绪队列，各级队列==优先级从高到低==，==时间片从小到大==。

  新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾。

  可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。



## 4.进程间通信方式

1. 管道

   在 shell 中，我们经常使用 | 将两个命令连接起来，它的作用是把前一个命令的输出作为输入后一个命令的输入。

   ![Pipe with one](https://gitee.com/Transmigration_zhou/pic/raw/master/pipe_with_one.jpg)

   1. 无名管道

     管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。

   2. 有名管道 

     有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是==先进先出==的通信方式。

2. 消息队列

   ![image-20220909161409746](https://gitee.com/Transmigration_zhou/pic/raw/master/image-20220909161409746.png)

   消息队列存放在内核中，可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

3. 共享内存

   ![Shared Memory](https://www.tutorialspoint.com/inter_process_communication/images/shared_memory.jpg)

   系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。

4. 套接字socket

   主要用于在客户端和服务器之间通过网络进行通信。

5. 信号

   用于通知接收进程某个事件已经发生，比如按下`ctrl + C`就是信号。

6. 信号量

   类似于计数器，控制多个进程多共享资源的访问。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。



## 5.死锁

### 什么是死锁?

若系统中存在一组进程(两个或两个以上进程)，其中每一

有关，二是与并发进程的执行速度有关。

### 死锁的条件

- 互斥条件：一段时间内某资源仅为一进程所占用。
- 请求和保持条件：已经得到了某个资源的进程可以再请求新的资源。
- 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
- 循环等待条件：死锁发生时，系统中一定有两个或以上的进程组成的一条环路，该环路中每个进程都在等待着下一个进程所占有的资源。

死锁发生时，以上四个条件一定是同时满足的，如果其中任何一个条件不成立，死锁就不会发生。

### 解决死锁的方法

- 把独占型资源改造成共享性资源，使资源可同时访问而不是互斥使用，即破坏互斥条件。
- 一次性分配所有的资源，这样进程就不会得到了某个资源再去请求新的资源了，即破坏请求条件；
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源，即破坏保持条件；
- 当某进程获得了部分资源，但得不到其他资源，则释放已占有的资源，即破坏不剥夺条件；
- 系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反，即破坏循环等待条件。



## 6.编译链接的过程

程序要运行起来，必须经过四个步骤：预处理、编译、汇编和链接。

- 预处理：展开#define宏定义，处理所有的条件编译指令#if等等，删除所有注释，插入包含的头文件，添加行号以便编译错误时能够显式行号，最后生成一个.i文件
- 编译：把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件，最后生成一个.s文件；
- 汇编：将汇编代码转换成机器可以执行的指令，最后生成一个.o文件；
- 链接：将有关的目标文件彼此相连接，即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。



## 7.分页、分段、快表(TLB)

分页：页表记录块号。页的大小固定，系统自动生成页号，一维（只需一个符号表示地址）。

分段：段表记录段长和基址。段的大小由用户定，相当于是y=ax+b，先找到ax然后+b，二维（程序员需要段名和段内偏移）。

页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。

段页：把主存先分成若干段，每个段又分成若干页



为了解决虚拟地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。

快表命中，只需一次访存 快表未命中，需要两次访存。

快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像



## 8.虚拟技术

虚拟技术指把一个物理实体转换为多个逻辑实体，主要有两种：时分复用技术和空分复用技术。

### 时分复用技术

多进程/多线程采用了时分复用技术，多个进程能在同一处理器上并发执行，让每个进程轮流占用处理器，每次只执行一小个时间片。

例子：既然一个程序需要被分配 CPU 才能正常执行，那为什么单核 CPU 的电脑中也能同时运行这么多个程序呢？

### 空分复用技术

虚拟内存使用了空分复用技术，将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，这些页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页从磁盘置换到内存中。空分复用技术的原理就是==把内存作为高速缓存来使用，只用来保存最频繁使用的部分程序，而把程序的大部分放在磁盘上==。

例子：这些程序同时运行需要的内存远大于 4 GB，那么为什么它们还可以在我的电脑上同时运行呢？



## 9.页面置换算法

- **最佳置换算法(OPT)**

  优先淘汰最长时间内不会被访问的页面。

  缺页率最小，性能最好；但无法实现

- **先进先出置换算法(FIFO)**

  优先淘汰最先进入内存的页面。

  实现简单；但性能很差，可能出现Belady异常

- **最近最久未使用置换算法(LRU)**

  优先淘汰最近最久没访问的页面

   性能很好；但需要硬件支持，算法开销大

- **时钟置换算法(CLOCK)**

  循环扫描各页面 第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第一轮没选中，则进行第二轮扫描。

  实现简单，算法开销小；但未考虑页面是否被修改过。

- **改进型的时钟置换算法**

  **(访问位，修改位)**的形式表示各页面状态

  第一轮:从当前位置开始扫描到第一个(0, 0)的帧用于替换。本轮扫描不修改任何标识位。表示该页面最近既未被访问，又未被修改，是最佳淘汰页。

  第二轮:若第一轮扫描失败，则重新扫描，查找第一个(1, 0)的帧用于替换。本轮将所有扫描过的帧访问位设为0。表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。 

  第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。本轮扫描不修改任何标识位。表示该页面最近已被访问，但未被修改，该页有可能再被访问。 

  第四轮:若第三轮扫描失败，则重新扫描，查找第一个(1, 1)的帧用于替换。表示该页最近已被访问且被修改，该页可能再被访问。

  算法开销较小，性能也不错



## 10.kill -9发生了什么？

`kill -9 pid`是向进程号为`pid`的进程发送`SIGKILL`信号，`SIGKILL`既不能被应用程序捕获，也不能被阻塞或忽略，其动作是立即结束指定进程。



## 11.硬链接和软链接的区别？

硬链接是指针，所有硬链接都指向同一个磁盘块，删除一个指针并不会真正删除文件，只有把指向该文件的所有指针全部删除，才会真的删除该文件；
软链接是另外一种类型的文件，保存的是它指向文件的全路径，访问时会替换成绝对路径，软链接可以理解为Windows上的快捷方式。



## 12.守护进程、孤儿进程与僵尸进程

- 守护进程是指==在后台运行，独立于控制终端，周期性地执行某种任务的进程==。Linux中大多数服务器就是用守护进程的方式实现的，如http进程等；

- 孤儿进程是指==父进程先退出，子进程还没有退出，此时子进程就是孤儿进程==，孤儿进程会被**init进程（进程号为1）**收养，当孤儿进程退出时，init进程会自动回收它们的状态；

  **孤儿进程不会有什么危害**

- 僵尸进程是指==子进程退出了，父进程没有退出且没有回收子进程的状态，此时子进程变为僵尸进程==，设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时间获取。僵尸进程会一只占用进程号，因为系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因没有可用的进程号而导致系统无法产生新的进程。

  如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。

### 如何避免僵尸进程？

- 父进程调用wait/waitpid等待子进程结束;
- 通过两次调用fork，父进程首先调用一个fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出，孙进程会变成孤儿进程由init进程领养。



## 13.用户态与内核态区别

- 用户态：用户态运行的进程可以直接读取用户程序的数据。

- 内核态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。

内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。



## 14.线程同步有哪些方式？

- 临界区

  每个进程中访问临界资源的那段代码称为临界区。临界资源是一次仅允许一个进程使用的共享资源。
  如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占，是属于进程维护的。

- 互斥量

  只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。

- 信号量

  它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。

- 事件

  通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。

  
