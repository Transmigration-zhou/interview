[toc]



## 1.进程与线程的区别

https://flying-veal.notion.site/a4ca2ea1cfda477f9063c86c00daab3a

[从 linux内核来看进程与线程的异同](https://blog.csdn.net/smilejiasmile/article/details/109389607)

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
2. 进程是资源分配的基本单位，线程是独立调度的基本单位。
3. 进程间**不共用**变量与资源；线程间**共用**变量与资源。
4. 线程的划分尺度小于进程，使得多线程程序的并发性高。
5. 线程不能够独立执行， 必须依存在进程中。
6. 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一进程下的所有线程共享该进程的内存空间，即共享堆、全局变量、静态变量、指针、引用、打开的文件等，而独自占有栈空间，线程之间切换的开销小；
7. 进程间通信需要借助操作系统（IPC），比较麻烦；线程间可以直接读写进程数据段来进行通信，但需要处理线程同步问题；

### 为什么要引入线程？

线程可以看作是轻量级的进程，但是它比进程更容易创建，也更容易撤销。（即线程成为独立调度的基本单位）



## 2.虚拟技术

虚拟技术指把一个物理实体转换为多个逻辑实体，主要有两种：时分复用技术和空分复用技术。

### 时分复用技术

多个进程能在同一个 CPU 上并发执行就是因为使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

例子：既然一个程序需要被分配 CPU 才能正常执行，那为什么单核 CPU 的电脑中也能同时运行这么多个程序呢？

### 空分复用技术

虚拟内存使用了空分复用技术，将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，这些页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页从磁盘置换到内存中。空分复用技术的原理就是==把内存作为高速缓存来使用，只用来保存最频繁使用的部分程序，而把程序的大部分放在磁盘上==。

例子：这些程序同时运行需要的内存远大于 4 GB，那么为什么它们还可以在我的电脑上同时运行呢？



## 3.编译链接的过程

程序要运行起来，必须经过四个步骤：预处理、编译、汇编和链接。

- 预处理：展开#define宏定义，处理所有的条件编译指令#if等等，删除所有注释，插入包含的头文件，添加行号以便编译错误时能够显式行号，最后生成一个.i文件
- 编译：把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件，最后生成一个.s文件；
- 汇编：将汇编代码转换成机器可以执行的指令，最后生成一个.o文件；
- 链接：将有关的目标文件彼此相连接，即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。



## 4.死锁

### 什么是死锁?

多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为死锁。

### 死锁的条件

- 互斥条件：每个资源要么已经分配给了一个进程，要么就是可用的；
- 占有和等待条件：已经得到了某个资源的进程可以再请求新的资源；
- 不可抢占条件：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放；
- 环路等待条件：死锁发生时，系统中一定有两个或以上的进程组成的一条环路，该环路中每个进程都在等待着下一个进程所占有的资源。

死锁发生时，以上四个条件一定是同时满足的，如果其中任何一个条件不成立，死锁就不会发生。

### 解决死锁的方法

- 一次性分配所有的资源，这样进程就不会得到了某个资源再去请求新的资源了，即破坏占有和等待条件；
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源，即破坏占有等待条件；
- 当某进程获得了部分资源，但得不到其他资源，则释放已占有的资源，即破坏不可抢占条件；
- 系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反，即破坏环路等待条件。



## 5.进程调度算法

- **先来先服务（FCFS）**

  非抢占式的调度算法，按照请求的顺序进行调度。

  有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

- **短作业优先（SJF）**

  非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

  长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

- **最短剩余时间优先（SRTN）**

  最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。

  如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

- **高相应比优先（HRRN）**

  响应比 =（等待时间+要求服务时间）/要求服务时间

- **时间片轮转（RR）**

  公平地、轮流地为各个进程服务，让每个进程在一定时间隔内都可以得到响应

  按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。

- **优先级调度**

  按照优先级高低进行调度，有抢占式和非抢占式。

  系统进程优先级 **高于** 用户进程
  前台进程优先级 **高于** 后台进程

  操作系统更**偏好 I/O型进程**

- **多级反馈队列**

  设置多级就绪队列，各级队列==优先级从高到低==，==时间片从小到大==。

  新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾。

  可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。




## 6.进程间通信方式

1. 管道

   - 无名管道

     管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。

   - 有名管道 

     有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是==先进先出==的通信方式。

2. 消息队列

   消息队列存放在内核中，可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

3. 共享内存

   系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。

4. 套接字socket

   主要用于在客户端和服务器之间通过网络进行通信。

5. 信号

   用于通知接收进程某个事件已经发生，比如按下`ctrl + C`就是信号。

6. 信号量

   类似于计数器，控制多个进程多共享资源的访问。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。



## 7.进程状态

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220321105451.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto)

- 就绪态（ready）：等待被调度
- 运行态（running）
- 阻塞态（waiting 等待态）：等待资源

### 引起进程状态转换的具体原因如下：

运行态→阻塞态：等待使用资源；如等待外设传输；等待人工干预。

阻塞态→就绪态：资源得到满足；如外设传输结束；人工干预完成。

运行态→就绪态：运行时间片到；出现有更高优先权进程。

就绪态→运行态：CPU 空闲时选择一个就绪进程。



## 8.kill -9发生了什么？

`kill -9 pid`是向进程号为`pid`的进程发送`SIGKILL`信号，`SIGKILL`既不能被应用程序捕获，也不能被阻塞或忽略，其动作是立即结束指定进程。



## 9.硬链接和软链接的区别？

硬链接是指针，所有硬链接都指向同一个磁盘块，删除一个指针并不会真正删除文件，只有把指向该文件的所有指针全部删除，才会真的删除该文件；
软链接是另外一种类型的文件，保存的是它指向文件的全路径，访问时会替换成绝对路径，软链接可以理解为Windows上的快捷方式。

