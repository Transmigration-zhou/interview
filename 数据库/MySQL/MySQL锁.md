## 锁机制与 InnoDB 锁算法

### MyISAM 和 InnoDB 存储引擎使用的锁：

- MyISAM 采用表级锁(table-level locking)。
- InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁



### 表级锁和行级锁：

- **表级锁：** MySQL 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。
- **行级锁：** MySQL 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

不管你是 MySQL 的什么存储引擎，对于表锁的策略都是一样的。

行级锁只在存储引擎层实现。



### 读锁和写锁：

对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。

对于并发读和并发写的问题，可以通过实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为 **共享锁（Shared Lock，S Lock）** 和 **排他锁（Exclusive Lock，X Lock）**，也叫 **读锁（readlock）** 和 **写锁（write lock）**：

- 共享锁 / 读锁：允许事务读（`select`）数据
- 排他锁 / 写锁：允许事务删除（`delete`）或更新（`update`）数据

读锁是共享的，或者说是相互不阻塞的。多个事务在同一时刻可以同时读取同一个资源，而互不干扰。写锁是排他的，也就是说一个写锁会阻塞其他的读锁和写锁，这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。

|      | S 锁     | X 锁   |
| ---- | -------- | ------ |
| S 锁 | **兼容** | 不兼容 |
| X 锁 | 不兼容   | 不兼容 |



### 意向锁

InnoDB 存储引擎支持 多粒度（granular）锁定，就是说允许事务在行级上的锁和表级上的锁同时存在。

意向锁是一个表级锁，其作用就是指明接下来的事务将会用到哪种锁。

- **意向共享锁（IS Lock）**：当事务想要获得一张表中某几行的共享锁（行级锁）时，InnoDB 存储引擎会自动地先获取该表的意向共享锁（表级锁）
- **意向排他锁（IX Lock）**：当事务想要获得一张表中某几行的排他锁（行级锁）时，InnoDB 存储引擎会自动地先获取该表的意向排他锁（表级锁）

意向锁之间是相互兼容的。

|       | IS 锁 | IX 锁 |
| ----- | ----- | ----- |
| IS 锁 | 兼容  | 兼容  |
| IX 锁 | 兼容  | 兼容  |

意向锁与**表级**读写锁之间大部分都是不兼容的，意向锁不会与**行级**的读写锁互斥。

|       | X 锁   | S 锁   |
| ----- | ------ | ------ |
| IS 锁 | 不兼容 | 兼容   |
| IX 锁 | 不兼容 | 不兼容 |



### InnoDB 存储引擎的锁的算法有三种：

- Record lock：记录锁，单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身

