[toc]

## 事务的特性(ACID)

1. **原子性（Atomicity）**： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么都做，要么都不做
2. **一致性（Consistency）**： 执行事务前后，数据保持一致，而且数据都是合法的，得满足业务规则
   - 例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的，且各自账户余额>=0，而在事务执行的过程中则不一定满足一致性
3. **隔离性（Isolation）**： 并发访问数据库时，**事务之间的执行互不影响**，各并发事务之间数据库是独立的
4. **持久性（Durability）**：事务结果一旦提交，对数据的修改就是永久的，即使数据库发生故障也不应该对其有任何影响



## 事务的实现（如何保证）

- 原子性：通过undo log（回滚日志）实现。
- 持久性：通过redo log（重做日志）实现。
- 隔离性：通过加锁（当前读）&MVCC（多版本并发控制，快照读）实现。
- 一致性：通过原子性、持久性、隔离性共同实现。

https://draveness.me/mysql-transaction/

https://www.jianshu.com/p/f0a1b00a6002

### 原子性

事务就是一系列的操作，要么全部都执行，要么全部都不执行。

想要保证事务的原子性，就意味着需要在操作发生异常时，对该事务所有之前执行过的操作进行**回滚**。

在MySQL中，这个回滚是通过==回滚日志(Undo Log)==实现的。简单的说，回滚日志就是记录了你所有操作的**逆操作**，在需要回滚时，就把这个事务的回滚日志里的操作全部执行一次。

- 当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
- 当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
- 当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作

**undo log**记录了这些回滚需要的信息，当事务发生异常触发ROLLBACK时，就按照日志逻辑地将回滚日志里的操作全部执行，从而达到“撤销”操作的效果。

### 持久性

持久性就是指，事务一旦被提交，那么数据一定会被写入到数据库中并持久储存起来。

另外，当事务被提交后就无法再回滚，如果想要撤销一个已经提交的事务，那就只能执行一个效果与其相反的事务，这也是持久性的一种体现。

与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用==重做日志（redo log）==实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。

当我们在事务中尝试对数据进行更改时，首先将数据从磁盘读入内存，更新内存缓存的数据，然后会生成一条重做日志（本次修改的逆操作）缓存，放在重做日志缓冲区中。当事务真正提交时，再将刚才缓冲区中的日志写入重做日志中做持久化保存，最后再把内存中的数据变动同步到磁盘上。

![Redo-Logging](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220320143038.jpg)

在 InnoDB 中，重做日志都是以 512B 的块的形式进行存储的，同时因为块的大小与磁盘扇区大小相同，所以重做日志的写入可以保证原子性，不会由于机器断电导致重做日志仅写入一半并留下脏数据。

**回滚日志**也是需要持久化储存的，因此他们也会创建对应的重做日志，在发生错误后，数据库重启时，会从重做日志中找出未被更新到的数据库磁盘上的日志，重新执行来满足事务的持久性。

#### 采用redo log的好处？

其实好处就是将**redo log**进行刷盘比对数据页刷盘效率高，具体表现如下：

- **redo log**体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
- **redo log**是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。



### 隔离性

事务的隔离性会跟并发等相关概念联系的非常密切，因为它主要就是为了保证并行事务处理能够达到“互不干扰”的效果。

隔离的实现说到底其实是**并发控制**，因此不同隔离级别的实现，其实就是采用了不同的并发控制机制。

**1.锁**

锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，不过在一个事务中，自然是不可能把整个数据库都加锁的，而是只对要访问的数据加锁（具体的粒度有行、表等）。而这些资源锁也是理所当然地分为共享锁（读锁 Shared S锁）和互斥锁（写锁 Exclusive X锁）两种。

读锁可以保证操作并发执行而不受影响，写锁则保证了更新数据库时不会受到其他事务的干扰。

**2.时间戳**

用时间戳实现隔离性，需要为记录配置两个字段

- **读时间戳**：用于保存所有访问该记录的事务中的最大时间戳（最后读取时间）
- **写时间戳**：用于保存将记录改到当前值的事务的时间戳（最后修改时间）

这样的事务在并行执行时，用的是**乐观锁**，先任由事务对数据进行修改，在写回去的时候在判断记录的时间戳有没有修改，如果没有被修改，就写入，否则，就生成一个新的时间戳并再次尝试更新数据。

PostgreSQL就使用了这种思想来控制事务。

**3.多版本和快照隔离**

通过维护多个版本的数据，数据库便可以允许事务并发执行遇到互斥锁时，转而读取旧版本的数据快照。这样就能显著地提升读取的性能，我们简称这一手段为MVCC。



### 一致性

数据库领域其实包含两个一致性，一个是 ACID 中的一致性、另一个是 CAP 定义中的一致性

#### ACID 中的一致性

事务的一致性定义基本可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束，还有触发器（插入文章的浏览记录时，使用触发器去更新对应文章的浏览量，保证每增加一条浏览记录，对应文章浏览量+1）等等。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性，这就是“一致”的意思。

数据库通过原子性、隔离性、持久性来保证一致性。

一致性也指逻辑上的对于开发者的要求，写出正确的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。

####  CAP 中的一致性

CAP 定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值。



## 并发一致性问题

1. 修改丢失：一个事务的更新操作被另一个事务的更新操作替换

2. 脏读：脏读指的是一个事务读取到==另一个事务已修改但未提交==的数据

   ![脏读](https://gitee.com/Transmigration_zhou/pic/raw/master/62edd2f78c61dc3b8e3a2998.png)

3. 不可重复读：指的是在同一个事务内，对同一数据的多次读取的结果不一样，一般是其它事务进行 update 或 delete 操作导致的

   ![不可重复读](https://gitee.com/Transmigration_zhou/pic/raw/master/eb655ff082ac36570b2dabe51c03e5ec.png)

4. 幻读：在一个事务内多次查询某个符合查询条件的记录数量，出现前后两次查询到的记录数量不一样的情况。幻读也属于不可重复读，但是一般是因为其它事务进行 insert  操作导致的。

   ![幻读](https://gitee.com/Transmigration_zhou/pic/raw/master/62edd4c58c61dc3b8e40613e.png)

### 回滚日志（undo log）和重做日志（redo log）

在数据库系统中，事务的原子性和一致性是由**事务日志**实现的，在具体的实现上，使用的就是之前提到的回滚日志和重做日志，它们保证了两点：

- 发生错误或者需要回滚的事务能够成功回滚（原子性）
- 事务提交后，数据还没来得及写入磁盘就宕机时，重启后能够成功恢复数据（一致性）

一条事务日志同时包含了修改前后的值，能够非常简单的进行回滚和重做两种操作。

|      | X 锁   | S 锁     |
| ---- | ------ | -------- |
| X 锁 | 不兼容 | 不兼容   |
| S 锁 | 不兼容 | **兼容** |



## 事务的隔离级别

### 隔离级别

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220303182428.png)

- 脏读：一个事务读到另外一个事务还没有提交的数据。

  ![img](https://pic3.zhimg.com/v2-0615e8417fec4174fab1a1b6519ec8da_r.jpg)

- 不可重复读：一个事务先后执行同一条 SQL，但两次读取到的数据不同。 

  ![img](https://pic3.zhimg.com/v2-ff1bf23ff6d0db40133204ef885a3b02_r.jpg)

- 幻读：在一个事务中明明没有查到主键为 X 的数据，但主键为 X 的数据就是插入不进去，就像某种幻觉一样。

  ![img](https://pic3.zhimg.com/v2-f1035c907509e4cbd6aa36e7aed8c392_r.jpg)



- 未提交读（read uncommitted）：指一个事务还没提交时，它做的变更就能被其他事务看到。
- 已提交读（read committed）：指一个事务提交之后，它做的变更才能被其他事务看到。
- 可重复读（repeatable read）：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的。==MySQL 的默认隔离级别==
- 串行化（序列化 serializable）：会对记录加上==读写锁==，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。（事务串行化顺序执行）

这四大隔离级别的隔离效果是逐渐增强的，但是性能是逐渐变差的。

不过要解决幻读现象不建议将隔离级别升级到「串行化」，因为这样会导致数据库在并发事务时性能很差（加锁）。

MySQL 的默认隔离级别虽然是「可重复读」，但是它通过Next-Key Locks（行锁和间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。

### 为什么隔离级别越高，性能越差？

因为四个隔离级别是通过加锁解决的并发问题，MySQL 中的锁可以分为共享锁/读锁、排它锁/写锁、间隙锁、行锁和表锁。

首先读未提交没有加锁，因此性能最好，但是也不能解决任何并发问题。

而串行化则在==读的时候加的是共享锁==，==写的时候加排它锁==阻塞其它事务的写入和读取，因此性能最差，但是可以解决所有的并发问题。

而读已提交和可重复读则是在解决一定并发问题时也能具有并发能力，所以使用的锁机制要优化很多，他们的底层使用的是 MVCC 进行实现的。

#### 共享锁（读锁）、排它锁（写锁）、间隙锁、行锁和表锁

- 共享锁是针对同一份数据，多个读操作可以同时进行，简单来说即读加锁，==不能写并且可并行读==。
- 排他锁针对写操作，假如当前写操作没有完成，那么它会阻断其它的写锁和读锁，即写加锁，其它==读写都阻塞 ==
- 行锁和表锁，是从锁的粒度上进行划分的。
  - 行锁锁定当前数据行，锁的粒度小，加锁慢，发生锁冲突的概率小，并发度高，行锁也是MyISAM和InnoDB的区别之一，InnoDB支持行锁并且支持事务 。
  - 表锁则锁的粒度大，加锁快，开销小，但是锁冲突的概率大，并发度低。
-  间隙锁则分为两种：`Gap Locks`和`Next-Key Locks`。
  - Gap Locks会锁住两个索引之间的区间，比如`select * from User where id>3 and id<5 for update`，就会在区间（3，5）之间加上Gap Locks。
  - Next-Key Locks是Gap Locks+Record Locks形成闭区间锁`select * from User where id>=3 and id=<5 for update`，就会在区间[3,5]之间加上Next-Key Locks。



## 这四种隔离级别具体是如何实现的呢？

对于「未提交读」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
对于「提交读」和「可重复读」隔离级别的事务来说，它们是通过Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 ReadView理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 ReadView，然后整个事务期间都在用这个ReadView。

---

以可重复读为例，mysql中每条数据在更新的时候都会产生一条回滚记录，这条记录主要在undo log中，当前数据的更新会构建出一条回滚链表，如下图所示，如果一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/webp)

当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view（快照）。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。

> 回滚日志什么时候会被删除？
>
> 在不需要的时候会被删除，系统会判断，如果已经没有事务需要这个回滚日志了，也就是涉及到当前快照的日志都提交了，那么回滚日志会被删除
>
> 当系统里没有比这个回滚日志更早的read-view的时候，就认为回滚日志不需要了。



## 多版本并发控制（MVCC）

https://blog.csdn.net/weixin_50924373/article/details/125090280

MVCC，即**Multi-Version Concurrency Control **。

MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。MVCC在MySQL InnoDB中的实现主要是为了提高数据库的并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。

定义：一条语句，能够看到当前快照之前己经提交的其它事务所做的修改

特点：

1. 读记录的历史版本，而非当前更新未提交版本
2. 无需加锁，读写不冲突



### 当前读和快照读

- **当前读**：读取的是记录的**最新版本**，读取时还要保证其他并发事务不能修改当前记录，**会对读取的记录进行加锁**。

  ```mysql
  select .....lock in share mode（共享锁）
  select .....for update
  update
  insert
  delete
  ```


- **快照读**：快照读又叫一致性读，读取的是历史版本的数据。不加锁的简单的SELECT都属于快照读，即不加锁的非阻塞读。
- 快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销，提高了数据库的并发性能。
  - 快照读的前提是隔离级别不是串行级别，**串行级别下的快照读会退化成当前读**

==**MVCC就是为了实现读和写冲突不加锁，而这个读指的就是快照读**，而非当前读，**当前读实际上是一种加锁的操作**，是悲观锁的体现。==



### MVCC能解决什么问题，有哪些好处？

1）读写之间阻塞的问题
2）降低了死锁的概率
3）解决一致性读的问题



**数据库的并发场景有三种，分别为：**

1. 读-读：不存在问题，不需要并发控制；
2. 读-写：有线程安全问题，可能遇到脏读、不可重复读、幻读；
3. 写-写：有线程安全问题，可能存在更新丢失问题，比如第一类更新丢失，第二类更新丢失；

多版本并发控制（MVCC）是一种用来解决**读-写冲突**的无锁并发控制。

为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读事务开始前的数据库的快照。所以MVCC可为数据库解决一下问题:

1. 在并发读写数据库时，可做到在读操作时不用阻塞写操作，写操作时也不用阻塞读操作，提高了数据库并发读写性能；
2. 同时解决了脏读、不可重复读等事务隔离问题（解决部分读写问题），但不能解决更新丢失的问题（写写冲突解决不了）。

为了不只让数据库采用悲观锁这样性能不佳的形式去解决并发问题，因此使用MVCC这样的非阻塞方式来解决问题，在数据库中，因为有了MVCC，所以我们可以形成两个组合：

1. MVCC+悲观锁
   MVCC解决度读-写冲突，悲观锁解决写-写冲突；
2. MVCC+乐观锁

这种组合的方式，在最大程度上提升DB的并发性能，并解决读-写冲突，和写-写冲突导致的问题。



### MVCC实现原理

- 隐式字段

  - **DB_TRX_ID**：创建或者最后一次修改记录的事务ID
  - **DB_ROW_ID**：隐藏主键
  - **DB_ROW_PTR**：回滚指针（指向上一个历史记录） —— 与undolog配合使用

- undo log 回滚日志

  - insert undo log

    代表事务在insert新记录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃；

  - update undo log

    事务在进行update或dalete时产生的undo log；不仅在事务回滚时需要，在快照读时也需要，所以并不能随便删除。
    对MVCC有帮助的实际是update undo log，undo log实际上就是保存数据的历史版本状态。
    ==当不同的事务对同一条记录做修改时，会导致该记录的undo log形成一个链表，链表的首链是最新的历史记录，而链尾是最早的历史记录。==

- readview

隐式字段和undo日志主要实现了多版本，readview实现了并发控制



### ReadView

readview就是事务在使用MVCC机制进行快照读操作时产生的读视图。使用readview可以实现对undo log版本链的控制。

#### readview的组成

- creator_trx_id：创建这个Read View的事务ID。
  - **只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。**
- trx_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表 。
- up_limit_id：活跃的事务中最小的事务ID（trx_ids中最小值）。
- low_limit_id：表示生成ReadView时系统中应该分配给下一个事务的id值。（系统中最大的事务id加上1就是low_limit_id）
  - **low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。**

#### readview的规则

这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

- 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
- 如果被访问版本的trx_id属性值小于ReadView中的up_limit_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
- 如果被访问版本的trx_id属性值大于或等于ReadView中的low_limit_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
- 如果被访问版本的trx_id属性值在ReadView的up_limit_id和low_limit_id之间，那就需要判断一下trx_id属性值是不是在trx_ids列表中：
  - 如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。
  - 如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。



### readview的生成时机

- READ COMMITTD：在每一次进行普通SELECT操作前都会生成一个ReadView

  ![img](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220312171523870-977119429.png)

- REPEATABLE READ：只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用第一次的ReadView就好了。

  ![img](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220312171536091-647209377.png)



## 开启事务的命令

1. `begin/start transaction`

   只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机。

2. `start transaction with consistent snapshot`

   执行这个命令就会马上启动事务。
