[toc]

## 事务的特性(ACID)

1. **原子性（Atomicity）**： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么都做，要么都不做
2. **一致性（Consistency）**： 执行事务前后，数据保持一致，而且数据都是合法的，得满足业务规则
   - 例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的，且各自账户余额>=0，而在事务执行的过程中则不一定满足一致性
3. **隔离性（Isolation）**： 并发访问数据库时，**事务之间的执行互不影响**，各并发事务之间数据库是独立的
4. **持久性（Durability）**：事务结果一旦提交，对数据的修改就是永久的，即使数据库发生故障也不应该对其有任何影响



## 事务的实现（如何保证）

- 原子性：通过undo log（回滚日志）实现。
- 持久性：通过redo log（重做日志）实现。
- 隔离性：通过加锁（当前读）&MVCC（多版本并发控制，快照读）实现。
- 一致性：通过原子性、持久性、隔离性共同实现。

https://draveness.me/mysql-transaction/

https://www.jianshu.com/p/f0a1b00a6002

### 原子性

事务就是一系列的操作，要么全部都执行，要么全部都不执行。

想要保证事务的原子性，就意味着需要在操作发生异常时，对该事务所有之前执行过的操作进行**回滚**。

在MySQL中，这个回滚是通过==回滚日志(Undo Log)==实现的。简单的说，回滚日志就是记录了你所有操作的**逆操作**，在需要回滚时，就把这个事务的回滚日志里的操作全部执行一次。

- 当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
- 当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
- 当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作

**undo log**记录了这些回滚需要的信息，当事务发生异常触发ROLLBACK时，就按照日志逻辑地将回滚日志里的操作全部执行，从而达到“撤销”操作的效果。

### 持久性

持久性就是指，事务一旦被提交，那么数据一定会被写入到数据库中并持久储存起来。

另外，当事务被提交后就无法再回滚，如果想要撤销一个已经提交的事务，那就只能执行一个效果与其相反的事务，这也是持久性的一种体现。

与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用==重做日志（redo log）==实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。

当我们在事务中尝试对数据进行更改时，首先将数据从磁盘读入内存，更新内存缓存的数据，然后会生成一条重做日志（本次修改的逆操作）缓存，放在重做日志缓冲区中。当事务真正提交时，再将刚才缓冲区中的日志写入重做日志中做持久化保存，最后再把内存中的数据变动同步到磁盘上。

![Redo-Logging](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220320143038.jpg)

在 InnoDB 中，重做日志都是以 512B 的块的形式进行存储的，同时因为块的大小与磁盘扇区大小相同，所以重做日志的写入可以保证原子性，不会由于机器断电导致重做日志仅写入一半并留下脏数据。

**回滚日志**也是需要持久化储存的，因此他们也会创建对应的重做日志，在发生错误后，数据库重启时，会从重做日志中找出未被更新到的数据库磁盘上的日志，重新执行来满足事务的持久性。

#### 采用redo log的好处？

其实好处就是将**redo log**进行刷盘比对数据页刷盘效率高，具体表现如下：

- **redo log**体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
- **redo log**是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。



### 隔离性

事务的隔离性会跟并发等相关概念联系的非常密切，因为它主要就是为了保证并行事务处理能够达到“互不干扰”的效果。

隔离的实现说到底其实是**并发控制**，因此不同隔离级别的实现，其实就是采用了不同的并发控制机制。

**1.锁**

锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，不过在一个事务中，自然是不可能把整个数据库都加锁的，而是只对要访问的数据加锁（具体的粒度有行、表等）。而这些资源锁也是理所当然地分为共享锁（读锁 Shared S锁）和互斥锁（写锁 Exclusive X锁）两种。

读锁可以保证操作并发执行而不受影响，写锁则保证了更新数据库时不会受到其他事务的干扰。

**2.时间戳**

用时间戳实现隔离性，需要为记录配置两个字段

- **读时间戳**：用于保存所有访问该记录的事务中的最大时间戳（最后读取时间）
- **写时间戳**：用于保存将记录改到当前值的事务的时间戳（最后修改时间）

这样的事务在并行执行时，用的是**乐观锁**，先任由事务对数据进行修改，在写回去的时候在判断记录的时间戳有没有修改，如果没有被修改，就写入，否则，就生成一个新的时间戳并再次尝试更新数据。

PostgreSQL就使用了这种思想来控制事务。

**3.多版本和快照隔离**

通过维护多个版本的数据，数据库便可以允许事务并发执行遇到互斥锁时，转而读取旧版本的数据快照。这样就能显著地提升读取的性能，我们简称这一手段为MVCC。



### 一致性

数据库领域其实包含两个一致性，一个是 ACID 中的一致性、另一个是 CAP 定义中的一致性

#### ACID 中的一致性

事务的一致性定义基本可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束，还有触发器（插入文章的浏览记录时，使用触发器去更新对应文章的浏览量，保证每增加一条浏览记录，对应文章浏览量+1）等等。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性，这就是“一致”的意思。

数据库通过原子性、隔离性、持久性来保证一致性。

一致性也指逻辑上的对于开发者的要求，写出正确的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。

####  CAP 中的一致性

CAP 定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值。



## 并发一致性问题

1. 修改丢失：一个事务的更新操作被另一个事务的更新操作替换

2. 脏读：脏读指的是一个事务读取到==另一个事务已修改但未提交==的数据

   ![脏读](https://gitee.com/Transmigration_zhou/pic/raw/master/62edd2f78c61dc3b8e3a2998.png)

3. 不可重复读：指的是在同一个事务内，对同一数据的多次读取的结果不一样，一般是其它事务进行 update 或 delete 操作导致的

   ![不可重复读](https://gitee.com/Transmigration_zhou/pic/raw/master/eb655ff082ac36570b2dabe51c03e5ec.png)

4. 幻读：在一个事务内多次查询某个符合查询条件的记录数量，出现前后两次查询到的记录数量不一样的情况。幻读也属于不可重复读，但是一般是因为其它事务进行 insert  操作导致的。

   ![幻读](https://gitee.com/Transmigration_zhou/pic/raw/master/62edd4c58c61dc3b8e40613e.png)

### 回滚日志（undo log）和重做日志（redo log）

在数据库系统中，事务的原子性和一致性是由**事务日志**实现的，在具体的实现上，使用的就是之前提到的回滚日志和重做日志，它们保证了两点：

- 发生错误或者需要回滚的事务能够成功回滚（原子性）
- 事务提交后，数据还没来得及写入磁盘就宕机时，重启后能够成功恢复数据（一致性）

一条事务日志同时包含了修改前后的值，能够非常简单的进行回滚和重做两种操作。

|      | X 锁   | S 锁     |
| ---- | ------ | -------- |
| X 锁 | 不兼容 | 不兼容   |
| S 锁 | 不兼容 | **兼容** |



## 事务的隔离级别

### 隔离级别

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220303182428.png)

- 脏读：一个事务读到另外一个事务还没有提交的数据。

  ![img](https://pic3.zhimg.com/v2-0615e8417fec4174fab1a1b6519ec8da_r.jpg)

- 不可重复读：一个事务先后执行同一条 SQL，但两次读取到的数据不同。 

  ![img](https://pic3.zhimg.com/v2-ff1bf23ff6d0db40133204ef885a3b02_r.jpg)

- 幻读：在一个事务中明明没有查到主键为 X 的数据，但主键为 X 的数据就是插入不进去，就像某种幻觉一样。

  ![img](https://pic3.zhimg.com/v2-f1035c907509e4cbd6aa36e7aed8c392_r.jpg)



- 未提交读（read uncommitted）：指一个事务还没提交时，它做的变更就能被其他事务看到。
- 已提交读（read committed）：指一个事务提交之后，它做的变更才能被其他事务看到。
- 可重复读（repeatable read）：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的。==MySQL 的默认隔离级别==
- 串行化（序列化 serializable）：会对记录加上==读写锁==，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。（事务串行化顺序执行）

这四大隔离级别的隔离效果是逐渐增强的，但是性能是逐渐变差的。

不过要解决幻读现象不建议将隔离级别升级到「串行化」，因为这样会导致数据库在并发事务时性能很差（加锁）。

MySQL 的默认隔离级别虽然是「可重复读」，但是它通过next−keylock锁（行锁和间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。

### 为什么隔离级别越高，性能越差？

因为四个隔离级别是通过加锁解决的并发问题，MySQL 中的锁可以分为共享锁/读锁、排它锁/写锁、间隙锁、行锁和表锁。

首先读未提交没有加锁，因此性能最好，但是也不能解决任何并发问题。

而串行化则在==读的时候加的是共享锁==，==写的时候加排它锁==阻塞其它事务的写入和读取，因此性能最差，但是可以解决所有的并发问题。

而读已提交和可重复读则是在解决一定并发问题时也能具有并发能力，所以使用的锁机制要优化很多，他们的底层使用的是 MVCC 进行实现的。

#### 共享锁（读锁）、排它锁（写锁）、间隙锁、行锁和表锁

- 共享锁是针对同一份数据，多个读操作可以同时进行，简单来说即读加锁，==不能写并且可并行读==。
- 排他锁针对写操作，假如当前写操作没有完成，那么它会阻断其它的写锁和读锁，即写加锁，其它==读写都阻塞 ==
- 行锁和表锁，是从锁的粒度上进行划分的。
  - 行锁锁定当前数据行，锁的粒度小，加锁慢，发生锁冲突的概率小，并发度高，行锁也是MyISAM和InnoDB的区别之一，InnoDB支持行锁并且支持事务 。
  - 表锁则锁的粒度大，加锁快，开销小，但是锁冲突的概率大，并发度低。
-  间隙锁则分为两种：`Gap Locks`和`Next-Key Locks`。
  - Gap Locks会锁住两个索引之间的区间，比如`select * from User where id>3 and id<5 for update`，就会在区间（3，5）之间加上Gap Locks。
  - Next-Key Locks是Gap Locks+Record Locks形成闭区间锁`select * from User where id>=3 and id=<5 for update`，就会在区间[3,5]之间加上Next-Key Locks。

## 这四种隔离级别具体是如何实现的呢？

对于「未提交读」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
对于「提交读」和「可重复读」隔离级别的事务来说，它们是通过Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 ReadView理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 ReadView，然后整个事务期间都在用这个ReadView。

---

以可重复读为例，mysql中每条数据在更新的时候都会产生一条回滚记录，这条记录主要在undo log中，当前数据的更新会构建出一条回滚链表，如下图所示，如果一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/webp)

当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view（快照）。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。

> 回滚日志什么时候会被删除？
>
> 在不需要的时候会被删除，系统会判断，如果已经没有事务需要这个回滚日志了，也就是涉及到当前快照的日志都提交了，那么回滚日志会被删除
>
> 当系统里没有比这个回滚日志更早的read-view的时候，就认为回滚日志不需要了。

## MVCC

MVCC，即**Multi-Version Concurrency Control （多版本并发控制）**。

最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，InnoDB通过undo log保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。

定义：一条语句，能够看到当前快照之前己经提交的其它事务所做的修改

特点：

1. 读记录的历史版本，非当前更新更新微提交版本
2. 无需加锁，读写不冲突

实现关键点：

1. 事务ID：唯一标识一个事物
2. ReadView：快照，某一个时刻系统内活跃事务ID的集合
3. row 特殊字段：事务ID与历史版本指针
4. undo：存放历史版本

https://flying-veal.notion.site/MVCC-undo-log-ReadView-e51f6b51561d4301860189d09c745974

### ReadView 机制

**ReadView 机制就是用来判断当前事务能够看见哪些版本的**，一个 ReadView 主要包含如下几个部分：

- `m_ids`：生成 ReadView 时有哪些事务在执行但是还没提交的（称为 “**活跃事务**”），这些活跃事务的 id 就存在这个字段里
- `min_trx_id`：m_ids 里最小的值。`trx_id < min_trx_id`，当前ReadView均可见
- `max_trx_id`：生成 ReadView 时 InnoDB 将分配给下一个事务的 ID 的值（事务 ID 是递增分配的，越后面申请的事务 ID 越大）。`trx_id > max_trx_id`，当前ReadView均不可见
- `creator_trx_id`：当前创建 ReadView 事务的 ID



## 开启事务的命令

1. `begin/start transaction`

   只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机。

2. `start transaction with consistent snapshot`

   执行这个命令就会马上启动事务。
