## 事务的特性(ACID)

1. **原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性：** 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. **隔离性：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性：** 一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。



## 并发一致性问题

1. 修改丢失：一个事务的更新操作被另一个事务的更新操作替换
2. 脏读：脏读指的是一个事务读取到==另一个事务已修改但未提交==的数据
3. 不可重复读：指的是在同一个事务内，对同一数据的多次读取的结果不一样，一般是其它事务进行 update 操作导致的
4. 幻读：幻读也属于不可重复读，但是一般是因为其它事务进行 insert 或 delete 操作导致的



## 事务的隔离级别

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220303182428.png)

- read uncommitted：读未提交。不能解决任何并发问题

- read committed：读已提交。只能解决脏读问题

- repeatable read：可重复读。只能解决脏读和不可重复读问题

- serializable：串行化 ( 序列化 )。都能解决

MySQL 默认的隔离级别是  repeatable read

这四大隔离级别的隔离效果是逐渐增强的，但是性能是逐渐变差的



## 为什么隔离级别越高，性能越差？

因为四个隔离级别是通过加锁解决的并发问题，MySQL 中的锁可以分为共享锁、排它锁、间隙锁、行锁和表锁

首先读未提交没有加锁，因此性能最好，但是也不能解决任何并发问题

而串行化则在读的时候加的是==共享锁==，写的时候加排它锁阻塞其它事务的写入和读取，因此性能最差，但是可以解决所有的并发问题

而读已提交和可重复读则是在解决一定并发问题时也能具有并发能力，所以使用的锁机制要优化很多，他们的底层使用的是 MVCC 进行实现的



## MVCC 的原理（undo log、ReadView）

https://flying-veal.notion.site/MVCC-undo-log-ReadView-e51f6b51561d4301860189d09c745974



## MySQL如何解决幻读

MySQL在REPEATABLE READ(可重复读)隔离级别实际上就已经解决了幻读问题

https://flying-veal.notion.site/MySQL-3d19104aec054289a9659a8a0afb6565



