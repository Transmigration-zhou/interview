[toc]

## 1.MySQL索引都有哪些分类？

https://segmentfault.com/a/1190000037683781

按数据结构分类可分为：B+tree索引、Hash索引（哈希索引）、Full-text索引（全文索引）。
按物理存储分类可分为：聚簇索引、二级索引（辅助索引）。
按字段特性分类可分为：主键索引、普通索引、前缀索引。
按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。

### 常用的索引

**普通索引**: 建立在普通字段上。

**唯一索引**: 建立在UNIQUE字段上。一张表可以有多个唯一索引，索引列的值必须唯一，但允许有空值。

**主键索引**: 建立在主键上的索引。一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。

**组合索引**(联合索引): 将数据库表中的多个字段(列)联合起来作为一个组合索引。为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。

**全文索引**: 全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找（全文索引用于==查找文本中的关键词==，而不是直接比较是否相等），允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR、TEXT类型列上创建。（MYSQL5.7版本之前只有MYISAM存储引擎支持）

**哈希索引**: 能以 O(1) 时间复杂度进行查找，但是失去了有序性。因此使用哈希索引==无法进行排序和分组==，并且只==支持精确查找==而==不支持部分查找和范围查找==





## 2.MySQL 的索引是什么？底层数据结构是什么？为什么要使用 B+ 树？

索引是保证 MySQL 高效获取数据的数据结构。MySQL 的索引是在存储引擎层实现的，因此不同的存储引擎可以具有不同的索引类型，==MyISAM 和 InnoDB 的默认索引类型都是 B+ 树，Memory 默认的索引类型是 Hash 索引==。



### 为什么用B+树而不用B树？
1. B+ 树更方便对数据进行遍历，并且由于==叶子节点上的数据是有序==的，因此也适合进行查询
2. B+树仅在叶子节点中存储全部的用户记录，而其他节点存储的只有主键和对应的页号，相比于B树在每个节点都存储完整的用户记录，B+树的树高更低，因此相同数据量下 B+ 树的树高度也更低，减少了磁盘 I/O 次数，查询效率更高。
3. 范围查找优势明显，B 树需要不断依赖==中序遍历+二分==，而 B+ 进行==二分查找到下限后顺序遍历找到上限==即可
4. 单次查找==性能稳定==，B+ 查找数据必须到叶子节点，而 B 树则有可能在非叶子节点上找到数据



### 为什么用B+树而不用红黑树？

==红黑树是平衡二叉树==

1. 红黑树必须存在内存里的，数据库表太大了，存不进去
2. 红黑树查找一个节点最多要查$logN$层，每一层都是一个内存页，使得磁盘IO的次数能够有效地减少（B+树比红黑树的深度更低）
2. 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会==预读==。预读过程中，==磁盘进行顺序读取，顺序读取不需要进行磁盘寻道==，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，==相邻的节点也能够被预先载入==。



### Redis 的索引为什么使用跳表而 MySQL 使用 B+树？

跳表适合内存搜索，而 B+ 适合磁盘搜索 ( 减少磁盘 I/O 次数 )



## 3.B+ 树一般有多少层？可以存放多少行数据？

一般是 ==2 ~ 3 层==，可以存放约==两千万行==的数据。



## 4.索引的优缺点

优点：

- 减少需要扫描的行数
- 辅助进行排序和分组，避免创建临时表影响性能

- 将**随机 I/O 变为顺序 I/O**
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

缺点：

- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。



## 5.索引的基本原理

索引用来**快速地寻找那些具有特定值的记录**。如果没有索引，一般来说执行查询时遍历整张表。

索引的原理：==就是把无序的数据变成有序的查询==。（两种排序方式）

①哈希索引：按索引字段进行哈希，哈希地址存的是数据地址

②B树索引：树中的节点id进行排序，id地址存的是数据地址

1、把创建了索引的列的内容进行==排序==

2、对排序结果生成==倒排表==。

3、在倒排表内容上拼上==数据地址链==。

4、在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据。



## 6.存储引擎

MyISAM 和 InnoDB的默认索引类型都是 B+ 树，Memory 默认的索引类型是 Hash 索引

### Memory

所有的数据存储在内存中，每个基于 Memory 创建的表实际对应一个磁盘文件，只存储表结构，而不存储数据文件。由于是基于内存的，因此 MySQL 进程关闭后数据就会消失

### MyIsam和InnoDB两个搜索引擎的区别

- 事务: MyISAM 不支持事务，而 InnoDB 支持事务。
- 并发: MyISAM 只支持表级锁，进行读操作时会加共享锁，写操作时则会加排它锁。在进行读操作时，可以通过并发插入来插入新的记录；而 InnoDB 支持表级锁和行级锁。
- 外键: MyISAM 不支持外键，而 InnoDB 支持外键。
- 崩溃恢复: MyISAM强调性能，但MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- MVCC(多版本并发控制): 只有InnoDB 支持。

### 如何选择 MyISAM 和 InnoDB

- 如果需要执行大量的SELECT查询，那么可以考虑使用 MyISAM；如果需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。
- 读写分离场景下，读数据库可以使用 MyISAM；写数据库则使用 InnoDB



## 7.聚簇索引和非聚簇索引（二级索引）的区别

聚簇索引：以==主键值==的大小作为页和记录的排序规则，在叶子节点处存储的记录包含了==存储一条记录中的**所有**信息==
非聚簇索引：以==索引列==的大小作为页和记录的排序规则，在叶子节点处存储的记录内容是==索引列 + 主键值==，若要获取完整的用户记录需要进行回表查询

![1233356-b5f463552cd8a380.png](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220226235302.png)



## 8.唯一索引和普通索引有什么区别，该如何选择？

https://flying-veal.notion.site/f8ca18e66854495387542f3744ec6dda

唯一索引和普通索引的不同点就在于，普通索引查找到满足条件的第一个记录后，还会继续去查找下一个记录，直到碰到第一个不满足该条件的记录；而对于唯一索引来说，一旦找到一个满足条件的记录后，就会立即停止继续检索。

不过这一点性能差距几乎是微乎其微，因为 InnoDB 存储引擎是按页进行读写的，所以说，当它找到符合某个条件的记录的时候，这条记录所在的数据页就已经都在内存里了。对于普通索引来说，无非就是再移动一次指针罢了。

真正能够区分唯一索引和普通索引差距的，在于 Insert Buffer / Change Buffer 的存在，因为它们==只适用于非唯一的辅助索引==。

在平常使用中，对于==写多读少==的业务，因为页面在写完以后马上被访问到的概率比较小，那么   Insert / Change Buffer 的Merge 操作就不会被频繁的执行，所以这个时候使用非唯一索引的性能就优于唯一索引（或者说，这个时候使用唯一索引会影响性能）。



## 9.什么时候应该建/不建索引？

什么时候应该建索引？

- ==主键==应该建立==唯一索引==
- ==频繁作为查询条件==的字段应该建索引

- ==查询中与其他表关联的字段==可以建立==外键索引==增加耦合度
- ==查询中排序和分组所依据的字段==应该建索引，这样可以大幅提高排序和分组的效率



什么时候不应该建索引？

- ==表记录太少==时，不应该建索引（没必要）
- ==经常增删改==的表不应该建索引 ( 索引可以提高查询速度，但是会降低表的更新速度 )
- ==数据重复且分布平均==的字段不应该建索引 ( 因为这样做没有太大的实际效果，比如性别字段不应该建索引 )
- ==不作为查询条件==的字段不应该建索引



## 10.索引失效情况（虽然建了索引，但是不会走索引的情况）

https://www.jianshu.com/p/47f140db89f0

1. 存在NULL值
2. 范围查询（<>、NOT、in、not exists、between）
3. 模糊查询以通配符%开头('%abc')
4. 若为字符串索引，与数值进行匹配的时候，==数值没用引号==，不走索引
5. 在搜索条件中，索引列不以单独的列名存在，而==使用表达式或函数进行操作==的时候，不走索引
6. 存储引擎不能使用索引中范围条件右边的列
7. 尽量使用覆盖索引(查询列和索引列一致)，避免`select *`
8. 用or它来连接时索引会失效

### 最左匹配原则

https://www.cnblogs.com/lanqi/p/10282279.html

最左匹配指的是从最左边为起点，任何连续的索引都能匹配上，同时==遇到范围查询就会停止匹配==

比如有一个复合索引的创建顺序为 (a，b，c，d)，而查询条件为 a=1 and b=2 and c>3 and d=4，这时 d 是用不到索引的，因为 c 是一个范围查询，其后面的字段会停止匹配，造成索引失效

最左匹配只针对复合索引有效，无论什么样的索引，底层都是 B+ 树，而复合索引的键值数量不是一个，而是多个。构建一棵 B+ 树只能根据一个值来建，因此数据库依据复合索引最左的字段来构建 B+ 树，而在最左字段值相同的情况下，第二个字段就是有序的，以此类推，如果遇到了作为范围查询的字段，那么这个字段的下一个字段就不一定是有序的了，也就无法利用索引

#### 讲一下联合索引的最左前缀原则，为什么得最左匹配，不按照这个来为什么失效？

最左前缀原则就是只要查询的是联合索引的最左 N 个字段，就可以利用该联合索引来加速查询。

原因就在于联合索引的 B+ 树中的键值是排好序的

### 联合索引(a,b,c)怎么样的顺序能用到索引

用到索引的有a,ab,abc,ac 因为优化器会自动调整and前后的顺序，所以ba,cba,bca,ca都会用到索引，其他的都不会用到该索引。==ac这一组仅仅是a用到索引。==

组合索引 有“最左前缀”原则，遇到范围查询(>、<、between、like)就会停止匹配。



## 11.回表查询和覆盖索引

https://flying-veal.notion.site/8f2c2a40d15c40cb8e239c2dbdfd8d4e



## 11.前缀索引

前缀索引就是选取字段的前几个字节建立索引。首先，InnoDB 限制了每列索引的最大长度不能超过 767 字节，所以，对于某些比较长的字段，如果确实有建立索引的必要，使用前缀索引不仅能够避免索引长度超过限制，而且相对于普通索引来说，占用的空间和查询成本更小。

不过前缀索引可能会导致两个问题：

第一个，使用前缀索引可能会增加记录扫描次数与回表次数，影响性能。针对这一点呢，其实前缀索引长度的选取还是很重要的，可能前缀定义的长一点，就能够大幅减少记录扫描次数和回表次数，所以，在建立前缀索引的时候，我们需要在占用空间和搜索效率之间做一个权衡

第二个，使用前缀索引其实就没法用覆盖索引对查询性能的优化了，因为 InnoDB 并不能确定前缀索引的定义是否截断了完整信息，就算是完全踩中了前缀索引，InnoDB 还得回表确认一次到底是不是满足条件了。



## 12.select * from A join B on A.id = B.id;执行过程性能差，原因可能是？哪里需要建立索引?

https://flying-veal.notion.site/select-from-A-join-B-on-A-id-B-id-ae3fecdfc523463bbf4d734dc274d9e8

这条语句性能差的原因可能是被驱动表 B 没有建立 name 索引。对于这条语句，我们可以在 B 表的 name 字段上建立索引。

==对于 join 语句来说，最好的情况就是可以用上被驱动表的索引==，这样用的就是 INL 算法

至于 join 语句的驱动表问题，==我们总是应该使用小表做驱动表==(小表驱动大表，即小数据集驱动大数据集)



## 13.介绍下 SQL 优化的方法	

https://flying-veal.notion.site/SQL-join-order-by-4940a2ac28fa49eab58a0362a69e2c7d

- 只返回必要的列：最好不要使用 select *
- 只返回必要的行：通过 where 和 limit 等进行限制
- 缓存重复的数据：借助缓存将经常被重复查询且不容易改变的数据进行存储，避免对数据库的重复查询

- 切分大查询

- 分解大连接查询

- 小表驱动大表

