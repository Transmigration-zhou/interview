[toc]

## MySQL索引都有哪些分类？

https://segmentfault.com/a/1190000037683781

按数据结构分类可分为：B+tree索引、Hash索引（哈希索引）、Full-text索引（全文索引）。
按物理存储分类可分为：聚簇索引、二级索引（辅助索引）。
按字段特性分类可分为：主键索引、普通索引、前缀索引。
按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。

### 常用的索引

**普通索引**: 建立在普通字段上。

**唯一索引**: 建立在UNIQUE字段上。一张表可以有多个唯一索引，索引列的值必须唯一，但允许有空值。

**主键索引**: 建立在主键上的索引。一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。

**组合索引**(联合索引): 将数据库表中的多个字段(列)联合起来作为一个组合索引。为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。

**全文索引**: 全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找（全文索引用于==查找文本中的关键词==，而不是直接比较是否相等），允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR、TEXT类型列上创建。（MYSQL5.7版本之前只有MYISAM存储引擎支持）

**哈希索引**: 能以 O(1) 时间复杂度进行查找，但是失去了有序性。因此使用哈希索引==无法进行排序和分组==，并且只==支持精确查找==而==不支持部分查找和范围查找==



## MySQL 的索引是什么？底层数据结构是什么？为什么要使用 B+ 树？

索引是保证 MySQL 高效获取数据的数据结构。MySQL 的索引是在存储引擎层实现的，因此不同的存储引擎可以具有不同的索引类型，==MyISAM 和 InnoDB 的默认索引类型都是 B+ 树，Memory 默认的索引类型是 Hash 索引==。



B+ 树非叶子节点只存储键值信息，数据记录都存放在叶子节点中。
B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。



### 为什么用 B+ 树而不用 B 树？

1. B+ 树更方便对数据进行遍历，并且由于==叶子节点上的数据是有序==的，因此也适合进行查询。
2. B+ 树==仅在叶子节点中存储全部的用户记录==，而其他节点存储的只有主键和对应的页号，相比于==B 树在每个节点都存储完整的用户记录==，B+ 树的树高更低，因此相同数据量下 B+ 树的树高度也更低，减少了磁盘 I/O 次数，查询效率更高。
3. 范围查找优势明显，B 树需要不断依赖==中序遍历+二分==，而 B+ 进行==二分查找到下限后顺序遍历找到上限==即可。
4. 单次查找==性能稳定==，B+ 查找数据必须到叶子节点，而 B 树则有可能在非叶子节点上找到数据。



### 为什么用 B+ 树而不用红黑树？

==红黑树是平衡二叉树==

1. 红黑树必须存在内存里的，数据库表太大了，存不进去。
2. 红黑树查找一个节点最多要查$logN$层，每一层都是一个内存页，使得磁盘IO的次数能够有效地减少（B+树比红黑树的深度更低）。
2. 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会==预读==。预读过程中，==磁盘进行顺序读取，顺序读取不需要进行磁盘寻道==，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，==相邻的节点也能够被预先载入==。



### Redis 的索引为什么使用跳表而 MySQL 使用 B+树？

跳表适合内存搜索，而 B+ 适合磁盘搜索 ( 减少磁盘 I/O 次数 )



## B+ 树一般有多少层？可以存放多少行数据？

一般是 ==2 ~ 3 层==，可以存放约==两千万行==的数据。



## 索引的优缺点

优点：

- 减少需要扫描的行数
- 辅助进行排序和分组，避免创建临时表影响性能

- 将**随机 I/O 变为顺序 I/O**
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

缺点：

- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。



## 索引的基本原理

索引用来**快速地寻找那些具有特定值的记录**。如果没有索引，一般来说执行查询时遍历整张表。

索引的原理：==就是把无序的数据变成有序的查询==。（两种排序方式）

①哈希索引：按索引字段进行哈希，哈希地址存的是数据地址

②B树索引：树中的节点id进行排序，id地址存的是数据地址

1、把创建了索引的列的内容进行==排序==

2、对排序结果生成==倒排表==。

3、在倒排表内容上拼上==数据地址链==。

4、在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据。



## 存储引擎

MyISAM 和 InnoDB的默认索引类型都是 B+ 树，Memory 默认的索引类型是 Hash 索引

### Memory

所有的数据存储在内存中，每个基于 Memory 创建的表实际对应一个磁盘文件，只存储表结构，而不存储数据文件。由于是基于内存的，因此 MySQL 进程关闭后数据就会消失

### MyIsam和InnoDB两个搜索引擎的区别

- 事务: MyISAM 不支持事务，而 InnoDB 支持事务。
- 并发: MyISAM 只支持表级锁，进行读操作时会加共享锁，写操作时则会加排它锁。在进行读操作时，可以通过并发插入来插入新的记录；而 InnoDB 支持表级锁和行级锁。
- 外键: MyISAM 不支持外键，而 InnoDB 支持外键。
- 崩溃恢复: MyISAM强调性能，但MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- MVCC(多版本并发控制): 只有InnoDB 支持。

### 如何选择 MyISAM 和 InnoDB

- 如果需要执行大量的SELECT查询，那么可以考虑使用 MyISAM；如果需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。
- 读写分离场景下，读数据库可以使用 MyISAM；写数据库则使用 InnoDB



## 聚簇索引和非聚簇索引（二级索引）的区别

聚簇索引：以==主键值==的大小作为页和记录的排序规则，在叶子节点处存储的记录包含了==存储一条记录中的**所有**信息==。

非聚簇索引：以==索引列==的大小作为页和记录的排序规则，在叶子节点处存储的记录内容是==主键值+索引列（指向真正的表数据的地址）==，若要获取完整的用户记录需要进行回表查询。

> **一般情况下，聚簇索引等同于主键索引，但这里有一个前提条件，那就是这张表需要有主键**，只有有了主键，它才能有主键索引，有主键索引才能等于聚簇索引。
>
> 使用主键索引查询：select * from user where id = 1，主键索引的叶子节点存储的是一行完整的数据，所以只需要搜索主键索引的B+Tree就可以轻松找到全部数据。
>
> 使用非主键索引查询：select * from user where name = ‘Jack’;非主键索引的叶子节点存储的是主键值，所以MySQL会先查询到name列的索引的B+Tree,搜索得到对应的主键值，然后再去搜索该主键值查询主键索引的B+Tree才可以找到对应的数据。
>
> 可以看出来，非主键索引要比主键索引多使用一次B+Tree。多使用的这次B+Tree其实就是==回表==。

聚簇索引的叶节点就是数据节点。

主键的叶子下包含了数据，其他索引指向主键

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200609203856304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phcnZhbjU=,size_16,color_FFFFFF,t_70)



非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200609163030931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phcnZhbjU=,size_16,color_FFFFFF,t_70)



## 覆盖索引
​	覆盖索引是非聚集复合索引的一种形式，包括查询中的 select、join 和 where 子句用到的所有列，如果这些列所需要的数据能够通过索引得到，那么就称索引覆盖了这些列 ( 即建立了索引的字段正好是查询中 select 子句和 where 子句涉及到字段，简单来说就是作为查询条件的索引包含了查询正在查找的所有字段 )，基于这些字段的查询不会出现回表。
​	因此如果使用覆盖索引，则 select 列表中最好只取出需要的字段，而不是 select *。但也不能将所有的字段作为复合索引，这样会导致索引文件过大，查询性能下降。

​	假设你定义一个联合索引，`CREATE INDEX idx_name_age ON user(name,age);`查询名称为 liudehua 的年龄` select name, age from user where name = ‘xxx’;`上述语句中，查找的字段 name 和 age 都包含在联合索引 `idx_name_age` 的索引树中，这样的查询就是覆盖索引查询。索引覆盖的效率比较高，推荐使用。其实通俗一点讲就是，把我们要查询的所有的字段都放到一个联合索引里面，这样我们我们就需要查询一个索引B+树就行了，就不用再进行回表查询其他的索引B+树了，效率比较高，推荐使用。



## 唯一索引和普通索引有什么区别，该如何选择？

https://juejin.cn/post/7158723510116810782

唯一索引：索引列中的值必须是唯一的，但是可以允许为空值(null)。

- 查询角度
  - 对于普通索引，查找到满足条件的第一个记录后，还会继续去查找下一个记录，直到碰到第一个不满足该条件的记录。
  - 对于唯一索引，由于索引保证了唯一性，一旦找到一个满足条件的记录后，就会立即停止继续检索。
- 更新角度
  - 如果新记录要更新的数据页在内存中
    - 对于唯一索引，找到合适的位置，判断有没有冲突，插入值，语句结束。
    - 对于普通索引，找到位置，插入值，语句结束。
  - 如果新记录要更新的数据页不在内存中
    - 对于唯一索引，将数据页读入内存，判断冲突，插入，语句结束。
    - 对于普通索引，将语句记录在 change buffer 中，语句结束。

真正能够区分唯一索引和普通索引差距的，在于 Insert Buffer / Change Buffer 的存在，因为它们==只适用于非唯一的辅助索引==。

在平常使用中，对于==写多读少==的业务，因为页面在写完以后马上被访问到的概率比较小，那么   Insert / Change Buffer 的 Merge 操作就不会被频繁的执行，所以这个时候使用非唯一索引的性能就优于唯一索引（这个时候使用唯一索引会影响性能）。



## 建/不建索引的场景

建立索引：

- ==主键==应该建立==唯一索引==
- ==频繁作为查询条件==的字段应该建索引（where条件字段）

- ==查询中与其他表关联的字段==可以建立==外键索引==增加耦合度（多表join关联查询，on字段两边的字段）
- ==查询中排序和分组所依据的字段==应该建索引，这样可以大幅提高排序和分组的效率（order排序，group by分组字段）



不应该建立索引：

- ==表记录太少==时，不应该建索引（没必要）
- ==经常增删改==的表不应该建索引 ( 索引可以提高查询速度，但是会降低表的更新速度 )
- ==数据重复且分布平均==的字段不应该建索引 ( 因为这样做没有太大的实际效果，比如性别字段不应该建索引 )
- ==不作为查询条件==的字段不应该建索引



## 索引失效情况（虽然建了索引，但是不会走索引的情况）

https://www.jianshu.com/p/47f140db89f0

1. 联合索引不满足最左匹配原则

2. 尽量使用覆盖索引(查询列和索引列一致)，避免`select *`

   如果select语句中的查询列，都是索引列，那么这些列被称为覆盖索引。这种情况下，查询的相关字段都能走索引，索引查询效率相对来说更高一些。

   使用select *查询所有列的数据，大概率会查询非索引列的数据，非索引列不会走索引，查询效率非常低。

3. 在搜索条件中，索引列不以单独的列名存在，而==使用表达式或函数进行操作==的时候，不走索引

4. 字段类型不同

   若为字符串索引，与数值进行匹配的时候，==数值没用引号==，不走索引

5. 模糊查询以通配符%开头（like '%a'）

6. 列对比

   如「user表中id字段和height字段，查询出这两个字段中值相同的记录」

   `explain select * from user *where* id=height`

   id字段本身是有主键索引的，同时height字段也建了普通索引的，并且两个字段都是int类型，类型是一样的。

   但如果把两个单独建了索引的列，用来做列对比时索引会失效。

7. 使用or关键字

   如果使用了or关键字，那么它前面和后面的字段都要加索引，不然所有的索引都会失效

8. 范围查询（<>、NOT、in、not exists、between）

9. `is null`，`is not null`也无法使用索引

### 最左匹配原则

https://www.cnblogs.com/lanqi/p/10282279.html

最左匹配指的是从最左边为起点，任何连续的索引都能匹配上，同时==遇到范围查询就会停止匹配==。

#### 讲一下联合索引的最左前缀原则，为什么得最左匹配，不按照这个来为什么失效？

最左前缀原则就是只要查询的是联合索引的最左 N 个字段，就可以利用该联合索引来加速查询。

原因就在于联合索引的 B+ 树中的键值是排好序的。

例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的

![img](https://img2018.cnblogs.com/blog/1281680/201901/1281680-20190117145740508-758737271.png)

例如 `a = 1 and b = 2` a, b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而`a>1 and b=2`，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。

### 联合索引(a,b,c)怎么样的顺序能用到索引

- 组合索引 有“最左前缀”原则，遇到范围查询(>、<、between、like)就会停止匹配。
- 优化器会自动调整 and 前后的顺序，比如 bca、cba 等价于 abc

```
a     a用到索引
ab    ab用到索引
abc   abc用到索引
ac    只有a用到索引
bc    都没有用到索引（8.0后会）

a=3 and b>7 and c=3    ab用到索引
a>4 and b=7 and c=9    a用到索引
a=3 order by b         ab用到索引
a=3 order by c         a用到索引
b=3 order by a         都没有用到索引
```

### 有联合索引（a, b），sql条件只有b，能用上索引吗

MySQL8.0增加了索引跳跃式扫描功能，当没有使用到联合索引的第一个字段且后续索引字段都使用到时，可能会触发索引跳跃式扫描，**会自动对联合索引中的第一个字段的值去重，然后基于去重后的值全部拼接起来查询**。

当第一列索引的唯一值较少时，即使where条件没有第一列索引，查询的时候也可以用到联合索引。
比如有如下sql：
 	SELECT * FROM table WHERE b=1;
优化器会将a所有可能的值枚举出来，然后把查询语句改成：
 	SELECT * FROM table WHERE a=0 AND b=1;
 	SELECT * FROM table WHERE a=1 AND b=1;
 	SELECT * FROM table WHERE a=2 AND b=1;
 	...
 前提是a可枚举的值数量较少，优化器会根据枚举值的数量来决定是否使用此特性。



## 查看是否使用索引的方法

MySQL的explain关键字查看是否使用索引。

explain显示了MySQL如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。简单讲，它的作用就是分析查询性能。

explain关键字的使用方法很简单，就是把它放在select查询语句的前面。

- type : 查询类型，有简单查询、联合查询、子查询等

  - 级别由低到高，查询速度越来越快

  | 类型          | 说明                                                         |
  | ------------- | ------------------------------------------------------------ |
  | ALL           | 全表扫描                                                     |
  | index         | 索引全扫描                                                   |
  | range         | 索引范围扫描                                                 |
  | ref           | 使用非唯一性索引或者唯一索引的前缀扫描                       |
  | eq_ref        | 使用的是唯一索引                                             |
  | const, system | 单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询 |
  | NULL          | MySQL不访问任何表或索引，直接返回结果                        |

- key : 使用的索引

- rows : 扫描的行数



## select * from A join B on A.id = B.id;执行过程性能差，原因可能是？哪里需要建立索引?

这条语句性能差的原因可能是被驱动表 B 没有建立 name 索引。对于这条语句，我们可以在 B 表的 name 字段上建立索引。

==对于 join 语句来说，最好的情况就是可以用上被驱动表的索引==，这样用的就是 INL 算法

至于 join 语句的驱动表问题，==我们总是应该使用小表做驱动表==(小表驱动大表，即小数据集驱动大数据集)g



## 如何给表增加一个字段/索引

- 如果数据量比较小（十几万），可以直接进行加字段操作`ALTER`。
- 如果数据量很大（百万、千万）
  - 临时表方法（这种方法会影响业务运行，为了保证数据完整需要停机）
    1. 创建一个临时的新表，首先复制旧表的结构（包含索引）
    2. 给新表加上新增的字段（此时新表是空表，加字段很快）
    3. 把原表数据导入新表
    4. 删除旧表，重命名新表的名字为旧表的名字
  - 在从库进行加字段操作，然后主从切换（适合读写特别频繁，但运维代价巨大）
    - 设置复制模式为statement
    - 新部署一个从库，在新从库直接alter改表
    - 等待从库改表完成，之后追上延迟
    - 同样操作到其他从库
    - 切换主从关系，让新从库成为主库
  - 使用在线ddl工具（适合表较大读写不是太大）
    - pt-osc(pt-online-schema-change) https://www.zhihu.com/question/400173530/answer/1849142298
    - gh-ost
