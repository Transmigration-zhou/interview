[toc]

## OSI 七层模型、TCP/IP模型

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220315122533.png)

- 物理层：底层数据传输，如网线；网卡标准。
- 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。
- 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。
- 传输层：端到端传输数据的基本功能；如 TCP、UDP。
- 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。
- 表示层：数据格式标识，基本压缩加密功能。
- 应用层：各种应用软件，包括 Web 应用。

说明：

- 在四层，既传输层数据被称作**段**（Segments）；
- 三层网络层数据被称做**包**（Packages）；
- 二层数据链路层时数据被称为**帧**（Frames）；
- 一层物理层时数据被称为**比特流**（Bits）。

![应用层](https://www.topgoer.com/static/6.1/2.png)

==TCP协议在传输层，IP协议在网络层，HTTP协议在应用层，DNS协议在应用层==

## ARQ协议

自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中**数据链路层**的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。

![在这里插入图片描述](https://gitee.com/Transmigration_zhou/pic/raw/master/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5ZWKYemYv-iKsQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png)

## TCP

### TCP 报文首部格式

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/1432327-20220430180557610-77129505.png)

**控制位（6个）**

- URG（紧急位）：该位1 的时候，表明此报文段中有紧急数据，尽快发送出去，不用在缓存中排队了，配合紧急指针使用，
- ACK（确认位）：该位为1时，表示已接收到发送方传输的数据。
- PUH（推送位）：该位为 1 时，要求接收方快速交付个应用程序，不再等到缓存满时再向上交付。
- RST（重置位）：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
- SYN（同步位）：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- FIN（终止位）：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。

### TCP 三次握手建立连接

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220309231458.png)

0）初始状态：客户端处于 `closed(关闭)`状态，服务器处于 `listen(监听)` 状态。

1）第一次握手：客户端向服务端发送一个 SYN 报文（SYN = 1）和初始序列号 ISN(x)，即图中的 seq = x，表示本报文段所发送的数据的第一个字节的序号。发送后客户端会进入 `SYN-SENT`状态

> SYN-SENT ：在发送连接请求后等待匹配的连接请求（发送等待状态）

2）第二次握手：服务器收到客户端的 SYN 报文之后，如果同意连接，会发送 SYN 报文（SYN = 1）作为应答，和初始化序列号 ISN(y)，即图中的 seq = y。同时会发送一个 ACK 报文，把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 `SYN_REVD`的状态。

> SYN-RECEIVED：在收到和发送一个连接请求后等待对连接请求的确认（确认接收状态）

3）第三次握手：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 `ESTABLISHED`状态。

服务器收到 ACK 报文之后，也处于 `ESTABLISHED`状态，至此，双方建立起了 TCP 连接。

> ESTABLISHED：代表一个打开的连接，数据可以传送给用户（确认连接状态）

总结：

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

#### ISN

TCP 初始序列号，ISN是发送方字节数据编号起点，目的是让对方生成一个合法的接收窗口。

##### 为什么是随机值

这样做主要是出于网络安全的因素着想。==如果 ISN 是固定的，攻击者很容易猜出后续的确认号==，攻击者很容易猜出后续的确认号，然后伪造序列号进行攻击。

#### 半连接队列

服务器第一次收到客户端的SYN之后，就会处于**SYN_RCVD**（同步已接收）状态，此时双方还没有完全建立连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称为半连接队列

#### 全连接队列

当已经完成三次握手，建立起的连接后，应用没有取走的请求会组成一个队列，这个队列就是全连接队列，如果队列满了可能就会出现请求丢失

#### TCP为什么是三次握手？

三次握手最主要的目的就是服务端和客户端双方都==确认自己与对方的发送与接收是正常的==。

- 第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常

- 第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：

  客户端确认了：自己发送、接收正常，对方发送、接收正常；

  服务器确认了：对方发送正常，自己接收正常
  
- 第三次握手（客户端发送 ACK 报文给服务器）：

  客户端确认了：自己发送、接收正常，对方发送、接收正常；

  服务器确认了：自己发送、接收正常，对方发送、接收正常

两次握手只能保证单向连接是畅通的。

#### 三次握手可以携带数据吗？

第一次不可以。第一次握手时如果携带数据，服务器很容易因为请求中携带大量数据而遭到攻击（SYN泛洪攻击）。

第二次不可以。第二次握手因为不确认客户端的接收是否正常，如果携带数据可能丢失，浪费资源。

第三次可以。

### TCP 四次挥手释放连接

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220309234950.png)

0）初始状态：刚开始双方都处于 `ESTABLISHED`状态。假如是客户端先发起关闭请求。

1）第一次挥手：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并**停止再发送数据，主动关闭 TCP 连接**。此时客户端处于 `FIN_WAIT1` 状态，等待服务端的确认。

> FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；

2）第二次挥手：服务器收到FIN报文后知道客户端想断开连接，但此时服务器不一定能做好准备，可能还有未传输完的消息，所以服务器只能先返回一个ACK报文段，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，并进入 `CLOSE_WAIT` 状态；

> CLOSE-WAIT - 等待从本地用户发来的连接中断请求；

**此时的 TCP 处于半关闭状态，客户端到服务端的连接释放**。客户端收到服务端的确认后，进入 `FIN_WAIT2`（终止等待 2）状态，等待服务端发出的连接释放报文段。

> FIN-WAIT-2 - 从远程TCP等待连接中断请求；

3）服务器已经准备好断开连接，向客户端发送FIN报文段，且指定一个序列号，关闭服务器到客户端的数据传输，服务器进入 `LAST_ACK`状态，等待客户端的确认。

> LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；

4）第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），然后客户端进入  **`TIME_WAIT` （时间等待）状态**并==等待2MSL时间后进入 `CLOSED`状态==，服务器收到客户端的FIN报文段后会进入 `CLOSED`状态，完成四次挥手。

> TIME-WAIT - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；

#### TCP为什么要四次挥手?

由于 TCP 的**半关闭**（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入**半关闭状态**。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就**完全关闭**了TCP连接。

#### TIME_WAIT

> MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文

### TCP 怎么保证可靠传输

==可靠传输就是保证接收方收到的字节流和发送方发出的字节流是完全一样的。==

TCP的可靠传输我认为是从【事前预防】和【事后补救】两个维度来搭建的

- **数据校验——事前预防**：TCP报文头有校验和，用于校验报文是否损坏。
- **确认应答机制——事前预防**：接收方收到 TCP 报文段后就会返回一个确认应答消息。
- **流量控制——事前预防**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- **拥塞控制——事后补救**：当网络拥塞出现丢包时，通过拥塞窗口，减少数据的发送，防止包丢失。
- **重传机制——事后补救**：发送方发送一段时间后没有收到确认就会重传。



### 拥塞控制实现的四种算法

慢开始、拥塞避免、快重传、快恢复

慢开始：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

拥塞避免：当拥塞窗口达到一个阈值时，窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。

快重传：要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）。

快恢复：当发送方连续收到三个重复确认，说明网络很可能没有发生拥塞，可以快速恢复。若出现拥塞，阈值变为当前窗口的一半，但拥塞窗口从新的阈值开始（而不是从1开始）。

#### 快重传和超时重传的区别

- 发生时机不同
  - 超时重传发生的时机是：如果某一个报文段的重传定时器超时后，该报文段依然没被确认，则重传该报文段。引起的原因是报文确认超时 ( 阻塞或者丢失 )
  - 快重传发生的时机是：接收方发送三个重复的 ACK 给发送方，发送方立即进行重传。引起的原因是接收方收到的报文无序 ( 比如报文发生丢失 )


### TCP粘包/拆包

一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。

### 原因

主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。

“粘包”可发生在发送端也可发生在接收端：

- 由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。
- 接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。

### 解决办法

出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。

封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。

#### 为什么UDP没有粘包/拆包？

- TCP协议是面向字节流的协议，UDP是面向报文的协议
  - UDP每一段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据
- UDP具有保护消息边界



## TCP 和 UDP 的区别

| **UDP**                      | **TCP**                            |
| ---------------------------------- | ---------------------------------------- |
| UDP无连接                          | TCP面向连接，全双工通信                        |
| 尽最大努力交付                     | 提供可靠的服务（不错、不丢、不重、有序） |
| 面向报文                           | 面向字节流                               |
| 没有拥塞控制                       | 有拥塞控制                               |
| 支持一对一，一对多，多对一和多对多 | 点到点                                   |
| 首部开销小                         | 首部开销大                               |



## 在浏览器中输入url地址后显示主页的过程

- 根据域名，进行DNS域名解析
- 拿到解析的IP地址，建立TCP连接
- 向IP地址，发送HTTP请求
- 服务器响应HTTP请求并返回HTTP报文
- 关闭TCP连接
- 浏览器解析HTML渲染页面



## DNS

DNS 是：

1. 一个由分层的 DNS 服务器实现的**分布式数据库**
   - 整个 DNS 系统由分散在世界各地的很多台 DNS 服务器组成，每台 DNS 服务器上都保存了一些数据，这些数据可以让我们最终查到主机名对应的 IP
2. 一个使得主机能够查询分布式数据库的**应用层协议**
   - 将**主机名转换成 IP 地址**

### 为什么需要 DNS 协议？(DNS 原理、DNS 协议有啥用)

由于 IP 地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过域名解析协议（DNS，Domain Name System）来将域名和 IP 地址相互映射，使我们可以更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 地址数串。

DNS 工作过程:

1）首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表；

2）若没有命中，则继续搜索操作系统的 DNS 缓存；

3）若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（主机和本地域名服务器之间的查询方式是递归查询）；

4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行迭代查询（本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：

- 首先本地域名服务器向根域名服务器发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案
- 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
- 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址

4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来

5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来

6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来

==总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。==

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220310222046.png)

==主机和本地域名服务器之间的查询方式是递归查询==

==本地域名服务器向根域名服务器的查询的迭代查询==

### DNS 协议基于 TCP 还是 UDP？

- ==域名解析使用UDP==：

  UDP快，UDP的DNS协议只要一个请求、一个应答就好了。

  而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是UDP协议传输内容不能超过512字节。

  不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。
- ==区域传输使用TCP==：（区域传输就是辅助域名服务器与主域名服务器通信，并同步数据信息的过程。）

  1. TCP协议可靠性好
  2. 数据同步传送的数据量比一个 DNS 请求和响应报文的数据量要多得多。

## session、cookie和token

cookie 是**服务器发送到用户浏览器并保存在本地的一小块数据**，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。

session 是另一种记录服务器和客户端会话状态的机制。session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中

抽象地概括一下：一个 cookie 可以认为是一个「变量」，形如 name=value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。

token 其实就是一串字符串而已，只不过它是被加密后的字符串，它通常使用 uid(用户唯一标识)、时间戳、签名以及一些其它参数加密而成，以作客户端进行请求的一个令牌。当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20221008175157.jpg)

**session 是空间换时间，token 是时间换空间。**

他们的目的都是一样的：**鉴权和认证。**

### Cookie和Session的区别

1、存储的位置不同。Cookie 在客户端（浏览器），Session 在服务器端。

2、存储的数据类型不同。Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。

3、安全性不同。Session 比 Cookie 安全。

4、存储大小不同。Cookie大小受浏览器的限制，一般单个Cookie保存的数据不能超过4K。Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

5、有效期不同。 Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。



## URI、URL

URI：统一资源标识符，用来唯一的标识一个资源。

URL：统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。

如果这个URI标识是一个可获取到上述对象的路径，那么它就是URL。

## HTTP、HTTPS

### HTTP

Http协议是由Http请求和响应组成。当在浏览器中输入网址访问某个网站时，浏览器会将你的请求封装乘一个Http请求发送给服务器，服务器接收到请求后会组织响应数据封装成一个Http响应返回给浏览器。

#### Http请求报文与响应报文格式

![img](https://img2018.cnblogs.com/blog/1066707/201907/1066707-20190723205939718-2050503049.png)

请求行、请求头、请求体、空行

![img](https://img2018.cnblogs.com/blog/1066707/201907/1066707-20190723210532026-600887604.png)

状态行、响应头、响应体、空行

##### Http首部

https://blog.csdn.net/weixin_39649965/article/details/110707143

**1、通用首部：**请求报文和响应报文都支持，换句话说，就是既可以出现在请求报文中，也可以出现在响应报文中。

**2、请求首部（请求头）：**出现在请求报文第一行(请求行)的后面，为请求报文添加一些附加信息

- Accept：浏览器可接受的MIME类型。

- Accept-Charset：浏览器可接受的字符集。
- Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。
- Accept-Language：浏览器支持的语言。
- Cookie：可以向服务器带数据。
- Content-Type：请求主体的内容是如何编码的。
- Content-Length：请求主体的字节数。
- Host：请求的服务器主机名。
- Referer：当前请求来自哪里。（直接访问不存在这个头，一般用于防盗链）
- User-Agent：客户端浏览器与操作系统相关信息。
- Connection：保持连接状态。Keep-Alive连接中，close已关闭。

**3、响应首部（响应头）：**出现在响应报文第一行的后面，提供了一些关于响应报文的一些信息

- Location：指定响应的路径，配合302状态码使用。
- Content-Type：返回的内容的类型，比如text/html;charset=UTF-8。
- Date：返回响应的时间
- Set-Cookie：设置与页面关联的Cookie
- Content-Encoding：文档的编码（Encode）类型。
- Content-Length：响应正文的长度。
- Content-Disposition：通过浏览器以下载的方式打开数据。
- Refresh：刷新时间+路径。
- Server：服务器名字。

**4、实体首部：**我们都知道，请求报文和响应报文都包含实体报文，实体首部就是用来描述实体报文的一些属性。

**5、扩展头部：**HTTP规范中没有定义的首部。

#### HTTP方法

- GET：获取资源
- POST：传输实体主体
- PUT：传输文件
- HEAD：获得报文首部，与GET方法一样，只是不返回报文主体内容。用于确认URI的有效性及资源更新的日期时间等。
- DELETE：删除文件，与PUT相反（响应返回204 No Content）
- OPTIONS：询问支持的方法，查询针对请求URI指定的资源支持的方法（Allow:GET、POST、HEAD、OPTIONS）

##### GET 和 POST 的区别

1. GET 方式的参数以查询字符串的形式出现在 URL 中；POST 方式的参数则存储在请求体中
2. GET URL长度有限制，POST没有限制
3. 由于 URL 只支持 ASCII 码，因此如果 GET 参数出现中文等字符就需要进行百分号编码转换； POST 支持标准字符集
4. GET 请求可以被收藏为书签，POST 不可以
5. GET 是具有幂等性，而 POST 不具有幂等性

> 幂等性指的是，同样的请求被执行一次与连续执行多次的效果是一样的， 服务器的状态也是一样的
>
> 在正确实现的条件下，GET、PUT、DELETE 等方法都是幂等的，而 POST 不是
>
> 两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI，所以POST方法不具备幂等性

#### HTTP状态码

| 状态码 | 类别                             | 含义                       |
| :----- | :------------------------------- | :------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出           |

##### 1xx 信息

- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

##### 2xx 请求正常处理完毕

- **200 OK**：客户端请求成功。
- **204 No Content** ：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。
- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

##### 3xx 重定向

- **301 Moved Permanently** ：永久重定向，表示请求的资源已经永久的搬到了其他位置。
- **302 Found** ：临时重定向，表示请求的资源临时搬到了其他位置
- **303 See Other** ：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

##### 4xx 客户端错误

- **400 Bad Request** ：请求报文中存在语法错误。
- **401 Unauthorized** ：未授权。没有带认证信息或者带了错误的认证信息, 这时客户端可以修改认证信息进行重试。
- **403 Forbidden** ：请求被拒绝。客户端带了正确的认证信息, 但服务器认为这个认证信息对应的用户是没有对应资源的访问权限的。
- **404 Not Found**：请求资源不存在。比如，输入了错误的 URL。

##### 5xx 服务器错误

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

#### HTTP 协议各版本

> HTTP 1.0：短连接——单工
> 客户端发起请求之后，服务端处理完请求并收到客户端的响应后即断开连接。
>
> HTTP 1.1：keep-alive——长连接——半双工
> 如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。
>
> HTTP 2.0：多路复用——全双工——允许服务端主动向客户端发送数据
> 一个 TCP 连接中 HTTP 请求发送可以一起发送

##### HTTP 1.1 和 HTTP 1.0 的区别

1. HTTP 1.0 默认使用短连接，客户端和服务器每次进行一次 HTTP 请求都需要新建一个 TCP 连接，任务结束就中断连接。

   HTTP 1.1 支持长连接和请求流水线处理，一个 TCP 连接上可以传输多个 HTTP 请求和响应，减少了建立和关闭连接的开销。

   HTTP 1.0中默认是关闭的，需要在http头加入"Connection: Keep-Alive"，才能启用Keep-Alive；HTTP 1.1中默认启用Keep-Alive，如果加入"Connection: close "，才关闭。

2. HTTP1.1引入 HOST 请求头。在 HTTP1.0 中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。

3. 错误通知管理 ：HTTP 1.1 新增了 24 个错误状态响应码。如 410 表示请求资源被永久删除。

4. 缓存处理：HTTP 1.1 在请求头引入更多和缓存相关的参数，以此来更灵活的支持缓存。

5. 节约带宽：HTTP 1.0 客户端在请求某个资源时，默认服务端将整个资源返回客户端。但很多时候客户端并不一定需要所有信息。HTTP 1.1 请求头引入 range 参数，通过配置它实现请求部分实体数据。并且客户端可以采用多线程并发访问某资源的不同段，充分利用带宽资源。

6. 断点续传：利用HTTP消息头使用分块传输编码，将实体主体分块进行传输。

##### HTTP 2.0 和 HTTP 1.1 的区别

1. 解析格式 ：HTTP1.1 的解析是基于文本的；HTTP2.0 的解析是二进制格式的，方便简单且鲁棒性高
2. 多路复用 ：HTTP1.1 中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，超过该数量的请求将会被阻塞；HTTP2.0 的多路复用则运行通过单一的连接发起多个请求-响应消息
3. 服务端推送 ：HTTP2.0 支持在客户端请求一个资源的同时将相关资源一起发送给客户端，同时在同源情况下，不同页面之间可以共享缓存资源
4. header 压缩：HTTP1.1 的 header 可能会携带大量信息且每次连接都要带上；HTTP2.0 通过使用哈夫曼编码减少需要传输的 header 大小，通讯双方各自缓存一份 header 字段表，避免了 header 的重复传输，也减小了 header 的大小

##### HTTP 3.0

HTTP 3.0和之间HTTP 1.x或HTTP 2.0的最大区别就是，它是基于UDP的，而以前的都是基于TCP的；使用UDP能减少RTT（往返时延）



#### HTTP优化方案

**TCP复用**：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。

**内容缓存**：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。

**压缩**：将文本数据进行压缩，减少带宽

**SSL加速**：使用SSL协议对HTTP协议进行加密，在通道内加密并加速

**TCP缓冲**：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。



#### HTTP与WebSocket的区别

**相同点：**

1. 都是基于tcp的，都是可靠性传输协议
2. 都是应用层协议

**不同点：**

1. **WebSocket是全双工（双向通信）协议，可以双向发送或接受信息**
2. **http本质还是一个半双工协议**
3. **WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的**



### HTTPS

HTTPS 主要对 HTTP 中**容易遭受攻击**的缺点进行了改进，主要有三点 ( 所有信息明文传播都有这些缺点 )

- HTTP 通信使用明文不加密，内容可能会**被窃听**，通过**加密解决**

- HTTP 不验证通信方的身份，因此可能**遭遇伪装**，通过**认证解决**

- HTTP 无法验证报文是否被篡改，所以有可能收到的报文已经遭**受到篡改**，通过**完整性保护解决**

==HTTPS = HTTP+加密+认证+完整性保护==

HTTPS 的本质其实是先和 SSL 进行通信，再由 SSL 和 TCP 进行通信

#### TLS四次握手（非对称加密）

HTTPS 首次通信需要 7 次握手（==TCP 三次握手 + TLS 四次握手==）

TLS 四次握手是在 TCP 建立连接之后进行的。

首先**第一次握手**客户端会向服务端发送client hello信息，告诉服务端需要的tls版本信息，支持的加密算法有哪些，这些算法组成加密套件，然后是一个随机数。

然后**第二次握手**服务端向客户端发送一个Server hello，然后告诉客户端服务端支持的确认支持的tls版本以及选择的加密套件，也会生成一个随机数告诉客户端，然后服务器出示一个证书，这样浏览器可以根据自己信任的证书列表来确认这个证书服务器是否可信，然后把公钥给客户端，再发后一个结束信号，Server Hello Done

**第三次握手**会使用公钥加密生成预主密钥给服务端，服务端使用私钥解密，接下来使用预祝密钥和前两个随机数组成最终的密钥进行密钥通信，

**第四次握手**服务端发送一个信号对客户端进行确认，加密通信开始。



#### 对称加密和非对称加密

对称加密：一份密钥
![](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220731005859.png)

非对称加密：公钥+密钥
![](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220731011207.png)

#### HTTPS请求过程

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/891671-20210702142547804-2020702159.png)

HTTPS 的整个通信过程可以分为两大阶段：证书验证和数据传输阶段，其中数据传输阶段又可以分为非对称加密和对称加密两个阶段。

1. 客户端向服务器的443端口发送https请求
2. 服务端向CA机构获取证书。颁发证书的同时会产生一个私钥和公钥。
3. 服务器响应客户端请求，将证书发送给客户端，证书包含公钥。
4. 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。
5. 客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。
6. 服务器使用私钥讲随机码 KEY 进行解密，获得密钥。
7. 服务器使用密钥 KEY 对数据进行对称加密并发送给客户端，客户端使用相同的密钥 KEY 解密数据。
8. 双方使用对称加密愉快地传输所有数据。

#### HTTPS中数字认证流程

https://www.cnblogs.com/fengf233/p/11775415.html

由于公钥在下发的时候也容易被替换劫持，所以需要个第三方认证机构确认公钥的正确性

CA：数字证书认证机构，是客户端服务端都认可的第三方机构，负责数字签名服务端公钥

数字签名：签名就是一种证明身份的机制，是一种校验机制（简单说是用私钥加密内容的hash,公钥解密对比hash判断内容是否完整）

数字证书：由一个可信的组织验证和签发的识别信息

![img](https://gitee.com/Transmigration_zhou/pic/raw/master/img/20220329123703.png)

### HTTP、HTTPS的区别

1. http是明文传输，https是加密的安全传输
2. http的端口默认是80，https的端口默认是443
3. http是无状态的连接，https是ssl加密的传输，身份认证的网络协议。
4. http的 URL 前缀是 `http://`，https的 URL 前缀是 `https://`
5. https比http耗费更多服务器资源
6. https协议要CA证书申请
