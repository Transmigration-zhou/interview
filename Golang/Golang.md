[toc]

## 基础语法

参考：https://geektutu.com/post/qa-golang-1.html

### 1. make 和 new 的区别

共同点：

1. new 和 make 都用于分配内存
2. new 和 make 都是在堆上分配内存

不同点：

1. new 对指针类型分配内存，返回值是分配类型的指针
2. make 用于 slice、map和 channel 的初始化，返回值为类型本身，而不是指针
3. new 分配的空间被清零，make 分配空间后，会进行初始化

### 2. 数组和切片的区别

1. 数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容
2. 数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变

### 3. 切片作为函数参数是传值还是传引用？

https://blog.csdn.net/m0_71777195/article/details/125502836

**Go里面函数传参只有值传递一种方式**

Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。

### 4. for range 的时候它的地址会发生变化么？

for range的时候，地址并没有发生变化。在循环时，会创建一个变量，之后每次循环时遍历到的数据都是以值覆盖的方式赋给这个变量。内存地址始终不变。

解决办法：在每次循环时，创建一个临时变量。

### 5. defer

https://blog.csdn.net/Cassie_zkq/article/details/108567205

#### 执行顺序

- 多个 defer 语句，遵从后进先出的原则，最后声明的 defer 语句，最先得到执行。
- defer 在 return 语句之后执行，但在函数退出之前，defer 可以修改返回值。

#### defer特性

1. 多个defer语句，按先进后出的方式执行

   所有的defer语句会放入栈中，在入栈的时候会进行相关的值拷贝（也就是下面的“对应的参数会实时解析”）。

2. defer声明时，对应的参数会实时解析

   辨析：defer后面跟无参函数、有参函数和方法

   ```go
   package main
   
   import "fmt"
   
   func test(a int) {//无返回值函数
   	defer fmt.Println("1、a =", a) //方法
   	defer func(v int) {
           fmt.Println("2、a =", v)
       }(a) //有参函数
   	defer func() {
           fmt.Println("3、a =", a)
       }() //无参函数
   	a++
   }
   func main() {
   	test(1)
   }
   
   /**
   3、a = 2
   2、a = 1
   1、a = 1
   */
   ```

3. 关键字 defer 用于注册延迟调用。

4. 这些调用直到 return 前才被执。因此，可以用来做资源清理。

   defer、return、返回值三者的执行逻辑应该是：
   return最先执行，return负责将结果写入返回值中；
   接着defer开始执行一些收尾工作；
   最后函数携带**当前返回值**（可能和最初的返回值不相同）退出。

   **有函数返回值的则return将结果写入返回值，defer进行收尾，可以看做 return最先执行，然后return将结果存入返回值，最后defer执行**

####  defer用途

1. 关闭文件句柄

   ```go
   unc ReadFile(filename string) ([]byte, error) {
       f, err := os.Open(filename)
       if err != nil {
           return nil, err
       }
       defer f.close()
       return ReadAll()
   }
   ```

2. 锁资源释放

   ```go
   var mu sync.Mutex
   var m = make(map[string]int)
    
   func lookup(key string) int {
       mu.Lock()
       defer mu.Unlock()
       return m[key]
   }
   ```

3. 数据库连接释放

### 6. byte 和 rune

byte等同于**uint8**，表示一个字节，常用来处理ascii字符

rune等同于**int32**，主要用于表示一个字符类型大于一个字节小于等于4个字节的情况下，常用来处理unicode或utf-8字符，特别是**中文字符。**

### 7. tag 和反射

反射可以在==运行期间==，操作任意类型的对象。

可以通过`TypeOf`方法获得对象类型。通过`ValueOf`获得对象值。

Go 中解析的 tag 是通过反射实现的。

tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。

### 8. 空 struct{} 的用途

使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。

1. 使用 map 表示集合 set 时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。

2. 使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。

3. 声明只包含方法的结构体。

## 实现原理

来源：https://geektutu.com/post/qa-golang-2.html

### 1. init() 函数是什么时候执行的？

 import –> const –> var –> init() –> main()

import : 由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。

### 2. Go 语言的局部变量分配在栈上还是堆上？

由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。

### 3. interface 进行比较

interface 的内部实现包含了 2 个字段，类型 T 和 值 V

- 两个接口值比较时，会先比较 T，再比较 V。
- 接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。

2 个 interface 相等有以下2种情况：

1. 两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）
2. 类型 T 相同，且对应的值 V 相等。

```go
func main() {
    var p *int = nil
    var i interface{} = p
    fmt.Println(i == p) // true
    fmt.Println(p == nil) // true
    fmt.Println(i == nil) // false
}
```

上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为`(T=*int, V=nil)`，i 与 p 作比较时，将 p 转换为接口后再比较，因此 `i == p`，p 与 nil 比较，直接比较值，所以 `p == nil`。

但是当 i 与 nil 比较时，会将 nil 转换为接口 `(T=nil, V=nil)`，与i `(T=*int, V=nil)` 不相等，因此 `i != nil`。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。

### 4. GC(垃圾回收)的工作原理

最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。

#### 标记清除

![image-20221016183237039](https://gitee.com/Transmigration_zhou/pic/raw/master/image-20221016183237039.png)

标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：

- 标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；
- 清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。

缺点

- STW，stop the world；让程序暂停，程序出现卡顿 **(重要问题)**；
- 标记需要扫描整个heap；
- 清除数据会产生heap碎片。

#### 三色标记

标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。

三色标记算法将程序中的对象分成白色、黑色和灰色三类。

- 白色：不确定对象。
- 灰色：存活对象，子对象待处理。
- 黑色：存活对象。

过程

- 每次新创建的对象，所有对象都是标记为“白色”（这一步需 STW ）
- 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合
- 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
- 重复**第三步**, 直到灰色中无任何对象
- 回收所有的白色标记表的对象，也就是回收垃圾



三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。

三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：

```
A (黑) -> B (灰) -> C (白) -> D (白)
```

正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。

```
A (黑) -> B (灰) -> C (白) 
  ↓
 D (白)
```

为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。

一次完整的 GC 分为四个阶段：

- 1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)
- 2）使用三色标记法标记（Marking, 并发）
- 3）标记结束(Mark Termination，需 STW)，关闭写屏障。
- 4）清理(Sweeping, 并发)

### 5. 函数返回局部变量的指针是否安全？

这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。



## 并发编程

来源：https://geektutu.com/post/qa-golang-3.html
