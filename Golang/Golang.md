[toc]

## 基础语法

### 1. make 和 new 的区别

共同点：

1. new 和 make 都用于分配内存
2. new 和 make 都是在堆上分配内存

不同点：

1. new 对指针类型分配内存，返回值是分配类型的指针
2. make 用于 slice、map和 channel 的初始化，返回值为类型本身，而不是指针
3. new 分配的空间被清零，make 分配空间后，会进行初始化

### 2. 数组和切片的区别

1. 数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容
2. 数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变

### 3. Go函数参数传递方式

https://blog.csdn.net/m0_71777195/article/details/125502836

**Go里面函数传参只有值传递一种方式**

> 值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
>
> 参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、channel等这些），这样就可以修改原内容数据。

> 所谓值类型：变量和变量的值存在同一个位置。
>
> 所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。

### 4. for range 的时候它的地址会发生变化么？

for range的时候，地址并没有发生变化。在循环时，会创建一个变量，之后每次循环时遍历到的数据都是以值覆盖的方式赋给这个变量。内存地址始终不变。

解决办法：在每次循环时，创建一个临时变量。

### 5. defer

https://blog.csdn.net/Cassie_zkq/article/details/108567205

#### 执行顺序

- 多个 defer 语句，遵从后进先出的原则，最后声明的 defer 语句，最先得到执行。
- defer 在 return 语句之后执行，但在函数退出之前，defer 可以修改返回值。

#### defer特性

1. 多个defer语句，按先进后出的方式执行

   所有的defer语句会放入栈中，在入栈的时候会进行相关的值拷贝（也就是下面的“对应的参数会实时解析”）。

2. defer声明时，对应的参数会实时解析

   辨析：defer后面跟无参函数、有参函数和方法

   ```go
   package main
   
   import "fmt"
   
   func test(a int) {//无返回值函数
   	defer fmt.Println("1、a =", a) //方法
   	defer func(v int) {
           fmt.Println("2、a =", v)
       }(a) //有参函数
   	defer func() {
           fmt.Println("3、a =", a)
       }() //无参函数
   	a++
   }
   func main() {
   	test(1)
   }
   
   /**
   3、a = 2
   2、a = 1
   1、a = 1
   */
   ```

3. 关键字 defer 用于注册延迟调用。

4. 这些调用直到 return 前才被执。因此，可以用来做资源清理。

   defer、return、返回值三者的执行逻辑应该是：
   return最先执行，return负责将结果写入返回值中；
   接着defer开始执行一些收尾工作；
   最后函数携带**当前返回值**（可能和最初的返回值不相同）退出。

   **有函数返回值的则return将结果写入返回值，defer进行收尾，可以看做 return最先执行，然后return将结果存入返回值，最后defer执行**

5. defer可以修改函数最终返回值，修改时机：有名返回值或者函数返回指针

####  defer用途

1. 关闭文件句柄

   ```go
   unc ReadFile(filename string) ([]byte, error) {
       f, err := os.Open(filename)
       if err != nil {
           return nil, err
       }
       defer f.close()
       return ReadAll()
   }
   ```

2. 锁资源释放

   ```go
   var mu sync.Mutex
   var m = make(map[string]int)
    
   func lookup(key string) int {
       mu.Lock()
       defer mu.Unlock()
       return m[key]
   }
   ```

3. 数据库连接释放

4. 配合recover()来恢复发生 panic

   ```go
   defer func() {
     if e := recover(); e != nil {
       if se, ok := e.(error); ok {
         err = se.Error()
       }
     }
   }()
   ```



### 6. 字符串

sring不可变，[]byte可变

#### byte 和 rune

byte等同于**uint8**，表示一个字节，常用来处理ascii字符

rune等同于**int32**，主要用于表示一个字符类型大于一个字节小于等于4个字节的情况下，常用来处理unicode或utf-8字符，特别是**中文字符。**

#### 字符串拼接

使用 + 拼接性能最差，strings.Builder，bytes.Buffer 相近，strings.Buffer 更快

原因：

- 字符串在 Go 语言中是不可变类型，占用内存大小是固定的
- 使用 +。每次都会重新分配内存
- strings.Builder，bytes.Buffer 底层都是[]byte 数组
- 内存扩容策略，不需要每次拼接重新分配内存



### 7. tag 和反射

反射可以在==运行期间==，操作任意类型的对象。

可以通过`TypeOf`方法获得对象类型。通过`ValueOf`获得对象值。

Go 中解析的 tag 是通过反射实现的。

tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。



### 8. 空 struct{} 的用途

使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。

1. 使用 map 表示集合 set 时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。
2. 使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。
3. 声明只包含方法的结构体。



### 9. 常量和变量的区别

1.  变量是“可读、可写”，而常量是“只读”的

2. 变量在运行期分配存储内存（非优化状态）

   常量通常会被编译器在预处理阶段直接展开，作为指令数据使用

   数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址



### 10. interface 比较

interface 的内部实现包含了 2 个字段，类型 T 和 值 V

- 两个接口值比较时，会先比较 T，再比较 V。
- 接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。

2 个 interface 相等有以下2种情况：

1. 两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）
2. 类型 T 相同，且对应的值 V 相等。

```go
func main() {
    var p *int = nil
    var i interface{} = p
    fmt.Println(i == p) // true
    fmt.Println(p == nil) // true
    fmt.Println(i == nil) // false
}
```

上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为`(T=*int, V=nil)`，i 与 p 作比较时，将 p 转换为接口后再比较，因此 `i == p`，p 与 nil 比较，直接比较值，所以 `p == nil`。

但是当 i 与 nil 比较时，会将 nil 转换为接口 `(T=nil, V=nil)`，与i `(T=*int, V=nil)` 不相等，因此 `i != nil`。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。



### 11. goroutine 内存泄漏

#### 原因

- Goroutine 内进行channel/mutex 等读写操作被一直阻塞。 

- Goroutine 内的业务逻辑进入死循环，资源一直无法释放。 

- Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待

#### 场景

- channel 如果忘记初始化，那么无论你是读，还是写操作，都会造成阻塞。 
- channel 发送数量 超过 channel接收数量，就会造成阻塞
- channel 接收数量 超过 channel发送数量，也会造成阻塞
- http request body未关闭，goroutine不会退出
- 互斥锁忘记解锁
- sync.WaitGroup使用不当

#### 排查

单个函数：调用 `runtime.NumGoroutine` 方法来打印 执行代码前后Goroutine 的运行数量，进行前后比较，就能知道有没有泄露了。

生产/测试环境：使用`PProf`实时监测Goroutine的数量。



### 12. init() 函数是什么时候执行的？

import –> const –> var –> init() –> main()

import : 由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。



## 底层数据结构

### 1. Slice

切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。

slice底层结构并没有使用加锁的方式，不支持并发读写，不是线程安全的。

现在有一个数组 a := [8] int {0, 1, 2, 3, 4, 5, 6, 7}，切片 s1 := a [:5]，相应示意图如下。

![slice](https://cdn.learnku.com/uploads/images/202302/07/24886/54qhsTWejC.png!large)

> 如果没有发生扩容，修改在原来的内存中
>
> 如果发生了扩容，修改会在新的内存中

#### 扩容机制

GO1.17版本及之前

1. 当新切片需要容量 > 两倍的原容量时，直接使用期望容量作为新切片的容量。

2. 如果原容量 < 1024，那么新切片的容量变成原来的 2 倍。（避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价）

3. 如果原容量 >= 1024，进入一个循环，每次容量变成原来的1.25倍（实际上是不超过25%），直到大于期望容量。（主要避免空间浪费）

GO1.18之后

1. 当新切片需要容量 > 两倍的原容量时，直接使用期望容量作为新切片的容量。

2. 当原容量 < threshold，新 slice 容量变成原来的 2 倍。（threshold=256）

3. 当原容量 > threshold，进入一个循环，每次容量增加 (旧容量+3*threshold)/4，直到大于期望容量。



### 2. Map

Golang 中 map 的底层实现是一个哈希表。map类型变量实际上是一个指针，指向hmap结构体，hmap包含多个bmap数组（桶）

```go
type hmap struct {
    count     int                  // 元素个数
    flags     uint8
    B         uint8                // B是buckets数组的长度的对数 2^B表示桶数量
    noverflow uint16               // 溢出的bucket个数
    hash0     uint32               // hash seed

    buckets    unsafe.Pointer      // 桶
    oldbuckets unsafe.Pointer      // 旧桶
    nevacuate  uintptr             // 即将迁移的旧桶编号

    extra *mapextra                // 用于扩容的指针
}
```

<img src="https://gitee.com/Transmigration_zhou/pic/raw/master/image-20230213002458315.png" alt="image-20230213002458315" style="zoom:50%;" />

#### 扩容机制

> 双倍扩容：分配新桶是旧桶的两倍，然后旧buckets数据搬迁到新的buckets。
>
> 等量扩容：不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，减少溢出桶的使用，进而保证更快的存取。
>
> 负载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。
> 负载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数。

1. 负载因子 = 哈希表存储的元素个数 / 桶个数（count/2^B^）> 6.5，触发双倍扩容

2. 溢出桶太多，触发等量扩容

   - 当桶数量 <= 2^15^ 时（B<=15），如果溢出桶总数(noverflow) >= 桶数量

   - 当桶数量 > 2^15^ 时，如果溢出桶总数 >= 2^15^

#### 查找过程

1. 写保护机制

   先查hmap的标志位flags，如果flags写标志位此时是1，说明其他协程正在写操作，直接panic

2. 计算hash值

3. key经过哈希函数计算后，得到64bit
   10010111 | 101011101010110101010101101010101010 | 10010

4. 找到hash对应的桶

   上面64位后5(hmap的B值)位定位所存放的桶
   如果当前正在扩容中，并且定位到旧桶数据还未完成迁移，则使用旧的桶

5. 遍历桶查找
   上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中，如果不在需要去溢出桶查找  

6. 返回key对应的指针

#### 冲突解决方式

采用链地址法解决冲突，具体就是插入key到map中时，当key定位的桶填满8个元素后，将会创建一个溢出桶，并且将溢出桶插入当前桶的所在链表尾部。

#### sync.Map

```go
type Map struct {
    mu Mutex
    read atomic.Value
    dirty map[any]*entry
    misses int
}
```

和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。

sync.Map里有两个map一个是专门用于读的read map，另一个是提供读写的dirty map；优先读read map，若不存在则加锁穿透读dirty map，同时记录一个未从read map读到的计数，当计数到达一定值，就将read map用dirty map进行覆盖

优点：通过读写分离，降低锁时间来提高效率；

缺点：不适用于大量写的场景，这样会导致read map读不到数据而进一步加锁读取，同时dirty map也会一直晋升为read map，整体性能较差。

适用场景：大量读，少量写。存在大量写的场景可以考虑map+metux



### 3. Channel

channel变量是一个存储在函数栈帧上的指针，指向堆上的hchan结构体

```go
type hchan struct {
    closed   uint32   // channel是否关闭的标志
    elemtype *_type   // channel中的元素类型

    buf      unsafe.Pointer // "环形"缓存区（数组）的位置
    qcount   uint           // 已经存储元素个数
    dataqsiz uint           // 最多存储元素个数
    elemsize uint16         // 每个元素占多大空间
    sendx    uint           // 写下标的位置
    recvx    uint           // 读下标的位置
    // 尝试读取channel或向channel写入数据而被阻塞的goroutine
    recvq    waitq  // 读等待队列
    sendq    waitq  // 写等待队列
    lock mutex //互斥锁，保证读写channel时不存在并发竞争问题
}
```

| 操作 \ 状态 | 未初始化         | 关闭                               | 正常             |
| ----------- | ---------------- | ---------------------------------- | ---------------- |
| 关闭        | panic            | panic                              | 正常             |
| 发送        | 永远阻塞导致死锁 | panic                              | 阻塞或者成功发送 |
| 接收        | 永远阻塞导致死锁 | 缓冲区为空则为零值，否则可以继续读 | 阻塞或者成功接收 |

如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费

如果多个 goroutine 都监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号



**向channel写数据的流程：**

1. 如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；
2. 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；
3. 如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；

**向channel读数据的流程：**

1. 如果等待发送队列sendq不为空且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；
2. 如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；
3. 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；
4. 如果缓冲区中没有数据，将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；



#### 无缓冲channel与容量为1的channel的区别

https://www.cnblogs.com/jo3yzhu/p/13559761.html

##### 无缓冲的channel

```go
c1 := make(chan int) // 无缓冲

c1 <- 1   // A
<- c1     // B
```

**这里的A或B，无论谁先执行，谁都会阻塞以等待另一个goroutine执行**，也就是说往里写得等来读的，从里读得等来写的。最重要的是，**A和B对c1的读写是同步的**，直观的理解是A和B对c1的读写是同时发生的，当A对c1写完了，则B从c1中就读完了。这样的特性可以用于做并发单位之间的同步操作，如果在A和B中对同一个无缓冲通道进行了读写，那么A和B一定会在读写的地方进行同步，谁先到谁阻塞等待另外一个。
综上，==如果在一个协程里写这样的代码，一定会死锁。==无缓冲的channel的读写者必须**同时完成发送和接收**，而不能串行，显然单协程无法满足。所以这里造成了循环等待，会死锁。

##### 缓冲为1的channel

```go
c2 := make(chan int, 1) // 有缓冲

c2 <- 1   // A
<- c2     // B
```

有缓冲的通道并不强制channel的读写者必须同时完成发送和接收，读者只会在没有数据时阻塞，写者只会在没有可用容量时阻塞，这就有点像阻塞队列了。



## 实现原理

来源：https://geektutu.com/post/qa-golang-2.html



### 2. Go 语言的局部变量分配在栈上还是堆上？

由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。

### 3. GC(垃圾回收)的工作原理

Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。

#### 标记清除

![image-20221016183237039](https://gitee.com/Transmigration_zhou/pic/raw/master/image-20221016183237039.png)

标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：

- 标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；
- 清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。

缺点

- STW，stop the world；让程序暂停，程序出现卡顿 **(重要问题)**；
- 标记需要扫描整个heap；
- 清除数据会产生heap碎片。

#### 三色标记

标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。

三色标记算法将程序中的对象分成白色、黑色和灰色三类。

- 白色：不确定对象。
- 灰色：存活对象，子对象待处理。
- 黑色：存活对象。

过程

- 每次新创建的对象，所有对象都是标记为“白色”（这一步需 STW ）
- 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合
- 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
- 重复**第三步**, 直到灰色中无任何对象
- 回收所有的白色标记表的对象，也就是回收垃圾



三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。

三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：

```
A (黑) -> B (灰) -> C (白) -> D (白)
```

正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。

```
A (黑) -> B (灰) -> C (白) 
  ↓
 D (白)
```

为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。

一次完整的 GC 分为四个阶段：

- 1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)
- 2）使用三色标记法标记（Marking, 并发）
- 3）标记结束(Mark Termination，需 STW)，关闭写屏障。
- 4）清理(Sweeping, 并发)

### 5. 函数返回局部变量的指针是否安全？

这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。

