# Go 内存管理

https://juejin.cn/post/7189525739836801085/

## 内存分配机制

Go的内存管理组件主要有：`mspan`、`mcache`、`mcentral`和`mheap`

- 内存管理单元：mspan
- 线程缓存：mcache
- 中心缓存：mcentral
- 页堆：mheap

### 分块

目标：为对象在heap上分配内存

- 提前将内存分块

  - 调用系统调用mmap()向OS申请一大块内存，如4 MB

  - 先将内存分成大块，例如8 KB，称作mspan

  - 再将大块继续划分成**特定大小**的小块，用于对象分配

  - noscan mspan：分配不包含指针的对象——GC不需要扫描

  - scan mspan：分配包含指针的对象——GC需要扫描

  ![A2D4F8AD-60D3-4ED3-86A9-8CF72B6E5220](https://gitee.com/Transmigration_zhou/pic/raw/master/A2D4F8AD-60D3-4ED3-86A9-8CF72B6E5220.png)

对象分配：根据对象的大小，选择最合适的块返回

### 缓存

![8F3C0309-7580-4ABB-9B5A-DC4E826A8F40](https://gitee.com/Transmigration_zhou/pic/raw/master/8F3C0309-7580-4ABB-9B5A-DC4E826A8F40.png)

> G：goroutine协程，使用go关键字可以创建一个golang协程。
>
> M：thread线程，协程必须放在线程上执行。
>
> P：processor处理器，包含运行Go代码的必要资源，也有调度goroutine的能力。

- 每个P包含一个mcache用于快速分配，用于为绑定于p上的g分配对象
- mcache管理一组mspan
- 当mcache中的mspan分配完毕，向mcentral申请带有未分配块的mspan
- 当mspan中没有分配的对象，mspan会缓存在mcentral中，而不是立刻释放并归还给OS
- 所有mcentral的集合则是存放于mheap中的。



### 分配流程

1. 首先通过计算使用的大小规格
2. 然后使用 mcache 中对应大小规格的块分配。
3. 如果 mcentral 中没有可用的块，则向 mheap 申请，并根据算法找到最合适的 mspan。
4. 如果申请到的 mspan 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。
5. 如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。



## 内存逃逸机制

在Go语言中，栈的内存是由编译器自动进行分配和释放的，栈区往往存储着函数参数、局部变量和调用函数帧，它们随着函数的创建而分配，随着函数的退出而销毁。但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从"栈"上逃逸到"堆"上的现象就成为内存逃逸。

==Go应用程序运行时，每个 goroutine 都维护着一个自己的栈区，这个栈区只能自己使用不能被其他 goroutine 使用。==

在栈上分配的地址，一般由系统申请和释放，不会有额外性能的开销，比如函数的入参、局部变量、返回值等。在堆上分配的内存，如果要回收掉，需要进行 GC，那么GC 一定会带来额外的性能开销。变量一旦逃逸会导致性能开销变大。

### 逃逸分析原则

- 不同于JVM的运行时逃逸分析，Go的逃逸分析是在编译期完成的：编译期无法确定的参数类型必定放到堆中；
- 如果变量在函数外部存在引用，则必定放在堆中；
- 如果变量占用内存较大时，则优先放到堆中；
- 如果变量在函数外部没有引用，则优先放到栈中；

查看逃逸的方法`go build -gcflags "-m -l" main.go `

### 产生逃逸的情况

- 函数返回后变量仍被使用的情况

  1. 返回指针

     变量在函数外部有引用，因此其生命周期大于栈，则溢出。

     ```go
     func escapeValue() *int{
         a := 1
         return &a
     }
     ```
     
2. 在一个切片上存储指针或带指针的值
  
   数组可能是在栈上分配的，但其引用的值一定是在堆上。
  
   ```go
     func escapeString() {
     	s := make([]*string, 10) //does not escape
     	a := "aaa"               //moved to heap: a
     	s[0] = &a
     }
   ```
  
3. 发送指针或带有指针的值到 channel 中。
  
   在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据，所以编译器没法知道变量什么时候才会被释放。
  
   ```go
     func escapeChannel() {
        var ch = make(chan *int, 1)
        var a = 10 //moved to heap: a
        var b = &a
        go func() {
           ch <- b
        }()
     }
   ```
  
4. 闭包调用
  
   导致函数返回后函数内变量仍被外部使用
  
   ```go
     func fibonacci() func() int {
     	a, b := 0, 1
     	return func() int {
     		a, b = b, a+b
     		return a
     	}
     }
   ```

- 变量占用内存较大被分配在堆上

  ```go
  s := make([]int, 10000, 10000)
  ```

- 参数是interface类型，比如fmt.Println(a ...interface{})的参数是`interface{}`

- 变量大小不确定

  ```go
  n := 1
  a := make([]int, n, n)
  ```

  

### 传值还是传指针？

传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

举个日常开发中函数传参例子：

有些场景下我们不应该传递结构体指针，而应该直接传递结构体。虽然直接传递结构体需要值拷贝，但是这是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。

当然这种做法不是绝对的，要根据场景去分析：

- 如果结构体较大，传递结构体指针更合适，因为指针类型相比值类型能节省大量的内存空间
- 如果结构体较小，传递结构体更适合，因为在栈上分配内存，可以有效减少GC压力



## 垃圾回收

### 基本概念

- 动态内存
  - 程序在运行时根据需求动态分配的内存：malloc()

- 自动内存管理（垃圾回收）：由程序语言的运行时系统管理动态内存

  - 避免手动内存管理，专注于实现业务逻辑

  - 保证内存使用的**正确性**和**安全性**

- 三个任务

  - 为新对象分配空间
  - 找到存活对象
  - 回收死亡对象的内存空间

> 一些名词解释：
>
> Mutator: 业务线程，分配新对象，修改对象指向关系
>
> Collector: GC 线程，找到存活对象，回收死亡对象的内存空间
>
> ![8E36D2C3-129A-4124-94A2-3462503707BB](https://gitee.com/Transmigration_zhou/pic/raw/master/8E36D2C3-129A-4124-94A2-3462503707BB.png)
>
> Serial GC: 只有一个 collector
>
> ![B5ED539C-50F9-429F-A8DB-4AD8CC708059](https://gitee.com/Transmigration_zhou/pic/raw/master/B5ED539C-50F9-429F-A8DB-4AD8CC708059.png)
> Parallel GC: 并行 GC，支持多个 collectors 同时回收的 GC 算法
>
> ![A0648E5B-C796-4272-8D9D-984DA2535197](https://gitee.com/Transmigration_zhou/pic/raw/master/A0648E5B-C796-4272-8D9D-984DA2535197.png)
>
> Concurrent GC: 并发 GC，支持 mutator(s) 和 collector(s) **同时执行**的 GC 算法
>
> ![3CE351A7-6F9B-46B8-8828-4B7795FA9BDF](https://gitee.com/Transmigration_zhou/pic/raw/master/3CE351A7-6F9B-46B8-8828-4B7795FA9BDF.png)



- 评价GC算法的四个维度
  - 安全性：不能回收存活的对象 ==基本要求==
  - 吞吐率：$ 1 - \frac{GC时间}{程序执行总时间} $ ==花在GC上的时间==
  - 暂停时间：stop the world（STW） ==业务是否感知==
  - 内存开销 ==GC元数据开销==



### GC 算法

常见GC算法有引用计数、分代收集、**标记清除**。

#### 标记清除

被回收的条件：不可达对象

过程：

- 标记根对象 (GC roots)

  - 静态变量、全局变量、常量、线程栈等

- 标记：找到可达对象

  - 求指针指向关系的传递闭包：从根对象出发，找到所有可达对象

- 清理：所有不可达对象 ==根据对象的生命周期，使用不同的标记和清理策略==

  - Copying GC：将存活对象复制到**另外的内存空间**

    ![B70869AA-BE18-44E8-BEBE-23A7CF719FDB](https://gitee.com/Transmigration_zhou/pic/raw/master/B70869AA-BE18-44E8-BEBE-23A7CF719FDB.png)

  - Mark-sweep GC：将死亡对象的內存标记为”可分配” （使用 free list 管理空闲内存）

    ![DA73BFB7-48B1-4FCD-B769-CC733F57C38B](https://gitee.com/Transmigration_zhou/pic/raw/master/DA73BFB7-48B1-4FCD-B769-CC733F57C38B.png)

  - Mark-compact GC：移动并整理存活对象（在原内存空间）

    ![A7E3BA6F-91B3-4AA3-B142-2047CDF2A376](https://gitee.com/Transmigration_zhou/pic/raw/master/A7E3BA6F-91B3-4AA3-B142-2047CDF2A376.png)

#### 分代 GC（Generational GC）

*Java中使用*

分代假说：most objects die young ==> 很多对象在分配出来后很快就不再使用了

每个对象都有年龄：经历过GC的次数

目的：对年轻和老年的对象，制定不同的GC策略，降低整体内存管理的开销

- 年轻代(Young generation)
  - 常规对象分配
  - 由于**存活对象很少**，可以采用copying collection
  - GC吞吐率很高
- 老年代(Old generation)
  - **对象趋向于一直活着，反复复制开销较大**
  - 可以采用mark-sweep collection

#### 引用计数

*python,swift,php中使用*

每个对象都有一个与之关联的引用数目，对象被引用时, 引用计数+1，对象被释放时，引用计数-1。如果引用计数为0，销毁对象。

对象存活的条件：当且仅当引用数大于0

优点

- 内存管理的操作被平摊到程序执行过程中
- 内存管理不需要了解runtime的实现细节：C++智能指针

缺点

- 维护引用计数的开销较大：通过原子操作保证对引用计数操作的原子性和可见性
- 无法回收环形数据结构——weak reference
- 内存开销：每个对象都引入的额外内存空间存储引用数目
- 回收内存时依然可能引发暂停



==运行时GC，编译时ARC==



### Go垃圾回收  

Go 语言采用的是标记清除算法，并在此基础上使用了三色标记法和写屏障技术，提高了效率。

一次完整的 GC 分为四个阶段：

1. 标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)
2. 使用三色标记法标记（Marking, 并发）
3. 标记结束(Mark Termination，需 STW)，关闭写屏障。
4. 清理(Sweeping, 并发)

> 开始STW：在开始标记阶段之前，需要进行一次短暂的STW，以确保所有的P（处理器）都停止在安全点，即一个不会修改堆的位置。这个STW时机是必要的，因为它能确保在标记阶段开始时，所有的goroutine都不会创建新的对象或修改现有对象的指针。这个STW的时间通常非常短。
>
> 结束STW：在标记阶段结束后，需要进行一次短暂的STW，以确保所有的goroutine都停止在安全点，然后进行最后一次的标记，并开始清除阶段。这个STW时机也是必要的，因为它能确保在清除阶段开始时，所有的对象都已经被正确地标记。这个STW的时间也通常非常短。
>
> 在标记阶段，Go的GC采用了并发标记的策略，即在goroutine运行的同时进行标记。这是通过写屏障（Write Barrier）实现的，写屏障在每次写入指针时都会标记该指针。这样，即使在标记阶段有新的对象被分配或旧的对象被更新，GC也能正确地标记这些对象。
>
> 在清除阶段，Go的GC采用了并发清除的策略，即在goroutine运行的同时进行清除。这是通过延迟清除（Lazy Sweeping）实现的，即只在需要分配新的对象时才清除那个对象所在的内存块。
>
> 这些策略大大减少了Go GC的STW时间，从而提高了程序的响应性和性能。



#### 标记清除

![image-20221016183237039](https://gitee.com/Transmigration_zhou/pic/raw/master/image-20221016183237039.png)

标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：

- 标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；
- 清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。

缺点

- STW，stop the world；让程序暂停，程序出现卡顿 **(重要问题)**；
- 标记需要扫描整个heap；
- 清除数据会产生heap碎片。

#### 三色标记

标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。

三色标记算法将程序中的对象分成白色、黑色和灰色三类。

- 白色：不确定对象。
- 灰色：存活对象，子对象待处理。
- 黑色：存活对象。

过程：

- 每次新创建的对象，所有对象都是标记为“白色”（这一步需 STW ）
- 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合
- 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
- 重复**第三步**, 直到灰色中无任何对象
- 回收所有的白色标记表的对象，也就是回收垃圾

> 其中，**根节点对象** 主要指执行 GC 时刻所有的 **全局对象** 和 **栈上的对象**（函数参数与内部变量）。

三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以==并发==地执行。但如果用户态程序在标记阶段更新了对象引用关系，就可能会导致问题的出现。

在 **A 对象已经被标记为 黑色 后**，用户程序修改了引用关系，将 **A 对象** 引用到 **白色对象 E**，而此时 A对象 已经被标记为黑色，gc 扫描不会再对它进行处理，最后，E 对象就会被错误的清除。

![img](https://pic4.zhimg.com/v2-742a0dc1acb94ae155945813557e7ac7_b.jpg)



**怎么防止以上问题的出现呢？**

首先，出现该问题是因为在 GC 执行的时候，用户程序并发的修改了对象引用关系，而且，修改的引用关系 **同时满足** 以下两个条件：

1. 黑色对象引用了白色对象；
2. 该白色对象没有被其他灰色对象引用 或者 灰色对象与它之间的可达关系遭到破坏。

解决方法是实现以下三色不变式：

- **强三色不变式**：黑色节点不允许引用白色节点。（黑不能直连白）
- **弱三色不变式**：黑色节点允许引用白色节点，但是该白色节点必须有其他灰色节点的引用或间接引用，破坏了条件二。（到达一个白色通路上一定要有灰）

![img](https://pic1.zhimg.com/v2-6100d47f9460322bbb9f9100ba9e11bc_b.jpg)

#### 写屏障(Write Barrier)

https://zhuanlan.zhihu.com/p/498143935

为了解决这个问题，Go 使用了==内存屏障==技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，实际上是一个hook（在基本的赋值操作基础上透明的添加额外的操作）。**基于对栈空间实现写屏障产生的性能损耗和实现复杂度的考虑，go 没有对栈空间对象使用写屏障。**

垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。

##### 插入写屏障

在**堆对象**增加引用对象的时候，先把该引用对象置为**灰色**，这样就可以保证不会有黑色对象引用白色对象，满足 **强三色不变式**。（黑连白，白变灰）

但是因为==栈空间对象是没有写屏障==的，因此，在标记过程中，可能出现**黑色的栈对象**引用到**白色对象**的情况，所以在一轮三色标记完成后**需要开启STW**，重新对**栈上的对象**进行三色标记。

优点：开始不需要stw全局扫描
缺点：后续需要stw修复栈内问题

##### 删除写屏障

在删除某对象的引用对象时，针对**被删除的对象**，如果自身为灰色，则不用处理，如果为白色，那么将该对象标记为灰色，满足**弱三色不变式** 。(被删除者变灰)

缺点：1. gc开始前stw扫描 2. 回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉
优点：后续无需stw

##### 混合写屏障

栈区：

栈上对象全部扫描标记为黑色（每个栈单独扫描，无需 STW 整个程序，停止单个扫描栈即可）；

GC 期间，任何在栈上创建的新对象，均为黑色（不用再对栈重新扫描）；

堆区：

被删除的对象标记为灰色（删除写屏障）；

被添加的对象标记为灰色（插入写屏障）。



#### GC触发时机

**主动触发：**

- 调用 `runtime.GC()` 方法，触发 GC。

**被动触发：**

- 定时触发，该触发条件由 `runtime.forcegcperiod` 变量控制，默认为 2 分钟。当超过两分钟没有产生任何 GC 时，触发 GC。
- 根据内存分配阈值触发，该触发条件由环境变量GOGC控制，默认值为100（100%），当前堆内存占用是上次GC结束后占用内存的2倍时，触发GC。
